<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java面试题 | Amm</title><meta name="keywords" content="学习"><meta name="author" content="Amm"><meta name="copyright" content="Amm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="javajava对比C++ Java是一门面向对象的编程语言  优点：  它在吸收C++语言的优点去除了C++语言中令人难以理解的概念(多继承、指针等) java语言在保证了强大的功能性的基础上，还比C++语言更为简单易用 java语言实现了面向对象理论，是静态面向对象编程语言的代表 它保证了程序员可以用优雅的思维方式进行复杂的编程 java还拥有平台独立性，可以做到”一次编译，到处运行” jav">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试题">
<meta property="og:url" content="https://ammwxgm.github.io/MMM/2022/10/25/java/index.html">
<meta property="og:site_name" content="Amm">
<meta property="og:description" content="javajava对比C++ Java是一门面向对象的编程语言  优点：  它在吸收C++语言的优点去除了C++语言中令人难以理解的概念(多继承、指针等) java语言在保证了强大的功能性的基础上，还比C++语言更为简单易用 java语言实现了面向对象理论，是静态面向对象编程语言的代表 它保证了程序员可以用优雅的思维方式进行复杂的编程 java还拥有平台独立性，可以做到”一次编译，到处运行” jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ammwxgm.github.io/MMM/img/cover.jpg">
<meta property="article:published_time" content="2022-10-25T10:23:56.000Z">
<meta property="article:modified_time" content="2022-10-25T13:07:34.957Z">
<meta property="article:author" content="Amm">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ammwxgm.github.io/MMM/img/cover.jpg"><link rel="shortcut icon" href="/MMM/img/favicon.png"><link rel="canonical" href="https://ammwxgm.github.io/MMM/2022/10/25/java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/MMM/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/MMM/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-25 21:07:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ammwxgm.github.io/MMM/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/MMM/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/MMM/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/MMM/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/MMM/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/MMM/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/MMM/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ammwxgm.github.io/MMM/img/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/MMM/">Amm</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/MMM/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/MMM/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/MMM/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-25T10:23:56.000Z" title="发表于 2022-10-25 18:23:56">2022-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-25T13:07:34.957Z" title="更新于 2022-10-25 21:07:34">2022-10-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="java对比C"><a href="#java对比C" class="headerlink" title="java对比C++"></a>java对比C++</h3><ul>
<li><p>Java是一门面向对象的编程语言</p>
</li>
<li><p>优点：</p>
<blockquote>
<p>它在吸收C++语言的优点去除了C++语言中令人难以理解的概念(多继承、指针等)</p>
<p>java语言在保证了强大的功能性的基础上，还比C++语言更为简单易用</p>
<p>java语言实现了面向对象理论，是<strong>静态面向对象</strong>编程语言的代表</p>
<p>它保证了程序员可以用优雅的思维方式进行复杂的编程</p>
<p>java还<strong>拥有平台独立性</strong>，可以做到”一次编译，到处运行”</p>
<p>java还提供了很多<strong>内置的类库</strong>，简化了程序设计工作，缩短了项目开发时间</p>
<p>java<strong>提供了垃圾回收器</strong>，开发人员从对内存的管理中解脱出来</p>
<p>java拥有良好的<strong>安全性和健壮性</strong></p>
<p>java语言经常被用在网络环境中，为了增强程序的安全性，java语言提供了一个防止恶意代码攻击的安全机制（<strong>数组边界检测</strong>和<strong>Bytecode校验</strong>等）</p>
<p>java的<strong>强类型机制、垃圾回收器、异常处理和安全检查机制</strong>使得用java语言编写的程序有很好的健壮性</p>
<p>java还提供了<strong>对Web应用开发的支持</strong>：例如Applet、Servlet和JSP可以用来开发Web应用程序</p>
<p>Socket、RMI可以用来开发分布式应用程序的类库</p>
</blockquote>
</li>
</ul>
<h3 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h3><h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><ul>
<li><p>Java8是一个拥有丰富特性的版本，新增了很多特性</p>
<blockquote>
<p><strong>Lambda表达式</strong>：该特性可以将功能视为方法参数，或者将代码视为数据</p>
<p>使用 Lambda 表达式，可以更简洁地表示单方法接口（称为功能接口）的实例</p>
<p><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器，</p>
<p>与Lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码</p>
<p>Java8对接口进行了改进：允许在接口中定义<strong>默认方法</strong>，默认方法<strong>必须使用default修饰</strong></p>
<p><code>Stream API</code>：新添加的<code>Stream API（java.util.stream）</code>支持对元素流进行函数式操作，<code>Stream API</code>集成在 <code>Collections API</code> 中，可以对集合进行批量操作，例如顺序或并行的 <code>map-reduce</code> 转换</p>
<p><code>Date Time API</code>：加强对日期与时间的处理</p>
</blockquote>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><blockquote>
<p>新建、可运行（就绪、运行）、阻塞（等待、超时等待）、终止</p>
<p><code>NEW</code> ：初始状态，线程被创建，但是还没有调用start方法</p>
<p><code>RUNNABLE</code>：可运行状态，线程<strong>正在<code>JVM</code>中执行</strong>，但是有可能在<strong>等待操作系统的调度</strong></p>
<p><code>BLOCKED</code> ：阻塞状态，线程正在<strong>等待获取监视器锁</strong></p>
<p><code>WTING</code> ：等待状态，线程正在<strong>等待其他线程的通知或中断</strong></p>
<p><code>TIMED_WTING</code>：超时等待状态，在<code>WTING</code>的基础上增加了超时时间，即超出时间自动返回</p>
<p><code>TERMINATED</code>：终止状态，线程已经执行完毕</p>
<blockquote>
<p>线程在创建之后默认为初始状态，在调用start方法之后进入可运行状态，可运行状态不代表线程正在运行，它有可能正在等待操作系统的调度</p>
<p>进入等待状态的线程需要其他线程的通知才能返回到可运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，除了他线程的唤醒，在超时时间到达时也会返回运行状态</p>
<p>此外，线程在执行同步方法时，在没有获取到锁的情况下，会进入到阻塞状态</p>
<p>线程在<strong>执行完run方法</strong>之后，会进入到终止状态</p>
</blockquote>
<p>Java将操作系统中的<strong>就绪</strong>和<strong>运行</strong>两个状态合并为可运行状态（RUNNABLE)</p>
<p>线程阻塞于<strong>synchronized的监视器锁</strong>时会进入<strong>阻塞状态</strong>，而线程阻塞于<strong>Lock锁</strong>时进入的却是<strong>等待状态</strong>，这是因为Lock接口实现类对于阻塞的实现均<strong>使用了<code>LockSupport</code>类中的相关方法</strong></p>
</blockquote>
<h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ul>
<li><p>继承Thread</p>
<blockquote>
<p>通过继承Thread类来创建线程的步骤如下</p>
<p>定义Thread类的子类，并重写该类的run()方法，该方法将作为线程执行体</p>
<p>创建Thread子类的实例，即创建了线程对象</p>
<p>调用线程对象的start()方法来启动该线程</p>
</blockquote>
</li>
<li><p>实现Runnable接口</p>
<blockquote>
<p>通过实现Runnable接口来创建线程的步骤如下</p>
<p>定义Runnable接口的实现类，并实现该接口的run()方法，该方法将作为线程执行体</p>
<p>创建Runnable实现类的实例，并将其作为参数来创建Thread对象，Thread对象为线程对象</p>
<p>调用线程对象的start()方法来启动该线程</p>
</blockquote>
</li>
<li><p>实现Callable接口</p>
<blockquote>
<p>通过实现Callable接口来创建线程的步骤如下</p>
<p>定义Callable接口的实现类，并<strong>实现call()方法</strong>，该方法将作为线程执行体</p>
<p>创建Callable实现类的实例，并以该实例作为参数，<strong>创建FutureTask对象</strong></p>
<p>使用FutureTask对象作为参数，<strong>创建Thread对象</strong>，然后启动线程</p>
<p>调用FutureTask对象的get()方法，获得子线程执行结束后的返回值</p>
</blockquote>
</li>
<li><p>总结</p>
<blockquote>
<p>创建线程的方式实际只有两种：<strong>继承父类和实现接口</strong></p>
<p>而继承父类和实现接口这两种方式的优缺点是：</p>
<p>采用接口的方式创建线程，优点是线程类还可以继承于其他类，并且多个线程可以共享一个线程体，适合多个线程处理同一份资源的情况，缺点是编程稍微麻烦一点点，如果需要访问当前线程，则必须使用Thread.currentThread()方法</p>
<p>采用继承的方式创建线程，优点是编程稍微简单一点点，缺点是因为线程类已经继承了Thread类，所以就不能继承其他的父类了</p>
<p>所以，通常情况下，更推荐采用接口的方式来创建线程</p>
<p>使用Runnable接口和Callable接口的方式，区别在于前者不能获得线程执行结束的返回值，后者可以获得线程执行结束的返回值</p>
</blockquote>
</li>
</ul>
<h4 id="4-3-run-和start-有什么区别？"><a href="#4-3-run-和start-有什么区别？" class="headerlink" title="4.3 run()和start()有什么区别？"></a>4.3 run()和start()有什么区别？</h4><ul>
<li><p>run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程</p>
<blockquote>
<p>调用start()方法启动线程时，系统会把该run()方法当成线程执行体来处理</p>
<p>但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行</p>
<p>也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</p>
</blockquote>
</li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li><p>线程池可以有效地管理线程</p>
<blockquote>
<p>可以<strong>管理线程的数量</strong>，可以避免无节制的创建线程，导致超出系统负荷直至崩溃</p>
<p>可以让<strong>线程复用</strong>，可以大大地减少创建和销毁线程所带来的开销</p>
<p>线程池需要依赖一些参数来控制任务的执行流程，其中最重要的参数有：</p>
<p><strong>corePoolSize（核心线程数）、workQueue（等待队列）、maxinumPoolSize（最大线程数）、handler（拒绝策略）、keepAliveTime（空闲线程存活时间）</strong></p>
</blockquote>
</li>
<li><p>申请线程资源处理过程</p>
<blockquote>
<p>判断线程数是否达到corePoolSize，若没有则新建线程执行该任务，否则进入下一步</p>
<p>判断等待队列是否已满，若没有则将任务放入等待队列，否则进入下一步</p>
<p>判断线程数是否达到maxinumPoolSize，如果没有则新建线程执行任务，否则进入下一步</p>
<p>采用初始化线程池时指定的拒绝策略，拒绝执行该任务</p>
<p>新建的线程处理完当前任务后，不会立刻关闭，而是继续处理等待队列中的任务</p>
<p>如果线程的空闲时间达到了keepAliveTime，则线程池会销毁一部分线程，将线程数量收缩至corePoolSize</p>
<blockquote>
<p>第2步中的队列可以有界也可以无界</p>
<p>若指定了无界的队列，则线程池永远无法进入第3步，相当于废弃了maxinumPoolSize参数</p>
<p>这种用法是十分危险的，如果任务在队列中产生大量的堆积，就很容易造成内存溢出</p>
<p>JDK为我们提供了一个名为Executors的线程池的创建工具，该工具创建出来的就是带有无界队列的线程池，所以一般在工作中我们是不建议使用这个类来创建线程池的</p>
</blockquote>
<blockquote>
<p>第4步中的拒绝策略主要有4个：</p>
<p>让<strong>调用者自己执行任务</strong>、<strong>直接抛出异常</strong>、<strong>丢弃任务不做任何处理</strong>、<strong>删除队列中最老的任务并把当前任务加入队列</strong></p>
<p>这4个拒绝策略分别对应着RejectedExecutionHandler接口的4个实现类，我们也可以基于这个接口实现自己的拒绝策略</p>
<p>在Java中，线程池的实际类型为ThreadPoolExecutor，它提供了线程池的常规用法</p>
<p>该类还有一个子类，名为ScheduledThreadPoolExecutor，它对<strong>定时任务提供了支持</strong></p>
<p>在子类中，我们可以周期性地重复执行某个任务，也可以延迟若干时间再执行某个任务</p>
</blockquote>
</blockquote>
</li>
<li><p>线程池的生命周期</p>
<blockquote>
<p>线程池的生命周期包含5个状态：</p>
<p>RUNNING、SHUTDOWN、STOP、TIDING、TERMINATED</p>
<p>这5种状态的状态值分别是：-1、0、1、2、3</p>
<p>在线程池的生命周期中，它的<strong>状态只能由小到大迁移</strong>，是不可逆的</p>
<p>RUNNING：表示线程池正在运行</p>
<p>SHUTDOWN：执行shutdown()时进入该状态，此时队列不会清空，线程池会等待任务执行完毕</p>
<p>STOP：执行shutdownNow()时进入该状态，此时现线程池会清空队列，不再等待任务的执行</p>
<p>TIDING：当<strong>线程池及队列为空</strong>时进入该状态，此时<strong>线程池会执行钩子函数</strong>，目前该函数是一个空的实现</p>
<p>TERMINATED：<strong>钩子函数执行完毕</strong>后，线程进入该状态，表示线程池已经死亡</p>
</blockquote>
</li>
</ul>
<h4 id="进程、线程、多线程"><a href="#进程、线程、多线程" class="headerlink" title="进程、线程、多线程"></a>进程、线程、多线程</h4><ul>
<li><p>进程：操作系统同时执行多个任务，一个任务就是一个进程</p>
</li>
<li><p>线程：一个进程同时执行多个任务，一个任务就是一个线程</p>
</li>
<li><p>进程与线程的关系</p>
<blockquote>
<p>线程是操作系统的最小调度单位（也称为轻量级的进程）</p>
<p>一个进程可以创建多个线程并发的处理多个任务</p>
<p>每个线程拥有各自的计数器、堆栈、局部变量</p>
<p>能够共享进程内的资源 &#x3D;&#x3D;&gt; 处理器可以在多个线程之间快速切换</p>
<p><strong>在线程中new出来的空间占的是进程的资源，也就是说是占用的堆资源(heap)</strong></p>
</blockquote>
</li>
<li><p>使用多线程的原因</p>
<blockquote>
<p>计算机处理器核心数量增加，程序使用多线程，可以将计算逻辑分配到多个处理器核心上，可以减少程序处理时间</p>
<p>期望更快的响应时间，针对复杂的业务，写出复杂的代码，使用多线程技术可以将<strong>数据一致性不强</strong>的操作派发给其他线程处理，可以缩短响应时间，提升用户的体验</p>
<p>java为多线程编程提供了<strong>良好且一致的编程模型</strong>，使开发人员更加专注于问题的解决，为该问题建立合适的业务模型，一旦建立好了业务模型，只需要稍作修改就可以将其方便地映射到Java提供的多线程编程模型上</p>
</blockquote>
</li>
<li><p>进程与线程的区别</p>
<blockquote>
<p>进程和线程的<strong>主要差别</strong>在于它们是<strong>不同的操作系统资源管理方式</strong></p>
<p><strong>进程有独立的地址空间</strong>，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间</p>
<p>进程和线程切换时，需要切换进程和线程的上下文，<strong>进程的上下文切换时间开销远远大于线程上下文切换</strong>时间，耗费资源较大，效率要差一些</p>
<p><strong>进程的并发性较低</strong>，<strong>线程的并发性较高</strong></p>
<p>每个独立的<strong>进程有一个程序运行的入口、顺序执行序列和程序的出口</strong>，但是<strong>线程不能够独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>
<p><strong>系统在运行的时候会为每个进程分配不同的内存空间</strong></p>
<p>而对线程而言，除了 CPU 外，系统不会为线程分配内存，线程组之间只能共享资源</p>
<p>一个<strong>进程崩溃后</strong>，在<strong>保护模式下不会对其他进程产生影响</strong>，但是<strong>一个线程崩溃整个进程都死掉</strong>，所以<strong>多进程要比多线程健壮</strong></p>
</blockquote>
</li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul>
<li><p><strong>守护线程</strong>是区别于用户线程，<strong>用户线程</strong>即我们手动创建的线程，而守护线程是程序运行的时候在后台提供一种<strong>通用服务的线程</strong></p>
<blockquote>
<p>垃圾回收线程就是典型的守护线程</p>
<p>守护线程和非守护线程的区别：</p>
<p>守护线程拥有<strong>自动结束自己生命周期的特性</strong>，非守护线程却没有</p>
<blockquote>
<p>举例：用户线程内部进行死循环时，程序会一直运行</p>
<p>但是如果时守护线程内部进行死循环，当所有用户线程结束后，守护线程也会终止运行，退出程序</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><ul>
<li>JUC是java.util.concurrent的缩写，这个包是JDK 1.5提供的并发包，包内主要提供了支持并发操作的各种工具</li>
</ul>
<blockquote>
<p>这些工具分为如下5类：原子类、锁、线程池、并发容器、同步工具</p>
<blockquote>
<p>原子类：</p>
<p>JDK 1.5开始，并发包下提供了atomic子包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式</p>
<p>在atomic包里一共提供了17个类，属于4种类型的原子更新方式，分别是<strong>原子更新基本类型</strong>、<strong>原子更新引用类型</strong>、<strong>原子更新属性</strong>、<strong>原子更新数组</strong></p>
<p>原子类会持有一个Unsafe对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>

<p><strong>内部有一系类原子更新方法都是依靠调用Unsafe对象的方法来实现，Unsafe类中的方法最终实现基本都是本地方法</strong>，基本都是通过CAS的方式来实现</p>
</blockquote>
<blockquote>
<p>锁：</p>
<p>从JDK 1.5开始，并发包中新增了<strong>Lock接口</strong>以及相关实现类用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时<strong>需要显式地获取和释放锁</strong></p>
<p>虽然它缺少了隐式获取释放锁的便捷性，但是却拥有了多种synchronized关键字所不具备的同步特性，包括：可中断地获取锁、非阻塞地获取锁、可超时地获取锁</p>
</blockquote>
<blockquote>
<p><strong>线程池</strong>：</p>
<p>从JDK 1.5开始，并发包下新增了内置的线程池</p>
<p>其中，ThreadPoolExecutor类代表常规的线程池，而它的子类ScheduledThreadPoolExecutor对定时任务提供了支持，在子类中我们可以周期性地重复执行某个任务，也可以延迟若干时间再执行某个任务</p>
<p>此外，Executors是一个用于创建线程池的工具类，由于该类创建出来的是带有无界队列的线程池，所以在使用时要慎重</p>
</blockquote>
<blockquote>
<p>并发容器：</p>
<p>从JDK 1.5开始，并发包下新增了大量高效的并发的容器，这些容器按照实现机制可以分为三类</p>
<p>第一类是以<strong>降低锁粒度</strong>来提高并发性能的容器，它们的类名以Concurrent开头，如ConcurrentHashMap</p>
<p>第二类是采用<strong>写时复制技术</strong>实现的并发容器，它们的类名以CopyOnWrite开头，如CopyOnWriteArrayList</p>
<p>第三类是<strong>采用Lock实现的阻塞队列</strong>，内部创建两个Condition分别用于生产者和消费者的等待，这些类都实现了BlockingQueue接口，如ArrayBlockingQueue</p>
</blockquote>
<blockquote>
<p>同步工具：</p>
<p>从JDK 1.5开始，并发包下新增了几个有用的并发工具类，一样可以保证线程安全</p>
<p>Semaphore类代表信号量，可以<strong>控制同时访问特定资源的线程数量</strong></p>
<p>CountDownLatch类则允许一个或多个线程等待其他线程完成操作</p>
<p>CyclicBarrier可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续运行</p>
</blockquote>
</blockquote>
<h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h4><ul>
<li><p>三种方式</p>
<blockquote>
<p>使用原子类</p>
<p>volatile（单个变量读写具有原子性，复合赋值时不具备原子性，保证可见性）</p>
<p>锁</p>
</blockquote>
</li>
<li><p>原子类：<code>JDK</code>从1.5开始提供了<code>java.util.concurrent.atomic</code>包</p>
<blockquote>
<p>在atomic包里一共提供了17个类，按功能可以归纳为4种类型的原子更新方式，分别是原子更新<strong>基本类型</strong>、原子更新<strong>引用类型</strong>、原子<strong>更新属性</strong>、原子更新<strong>数组</strong></p>
<p>无论原子更新哪种类型，都要遵循“<strong>比较和替换</strong>”规则，即比较要更新的值是否等于期望值，如果是则更新，如果不是则失败</p>
</blockquote>
</li>
<li><p>volatile：它轻量级的synchronized</p>
<blockquote>
<p>它保证了多处理器开发中共享变量的“可见性”，从而可以保证单个变量读写时的线程安全</p>
<blockquote>
<p>可见性：可见性问题是由处理器核心的缓存导致的，每个核心均有各自的缓存，而这些缓存均要与内存进行同步</p>
</blockquote>
<p>当写一个volatile变量时，该线程本地内存中的共享变量的值会被<strong>立刻刷新到主内存</strong></p>
<p>当读一个volatile变量时，该线程本地内存会被置为无效，迫使<strong>线程直接从主内存中读取</strong>共享变量</p>
</blockquote>
</li>
<li><p>锁：通过synchronized关键字和Lock接口</p>
<blockquote>
<p>synchronized是比较早期的<code>API</code>，在设计之初没有考虑到<strong>超时机制</strong>、<strong>非阻塞形式</strong>、<strong>多个条件变量</strong>等</p>
<p><code>JDK</code>的开发团队在1.5新增了Lock接口，并通过Lock支持了上述的功能，即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）</p>
</blockquote>
</li>
<li><p>总结：前两者用于保证单个共享变量的线程安全，锁可以保证临界区内多个共享变量的线程安全</p>
</li>
<li><p>扩展</p>
<blockquote>
<p>1.无状态设计：避免在并发环境中设置共享变量</p>
<p>2.不可变设计：当共享变量在并发环境中为只读，可以将变量设计为不可变的，变量前用final修饰，如果是引用变量则将其设置为不可变类型（String等）</p>
<p>3.并发工具 <code>java.util.concurrent</code>包提供了几个有用的并发工具类，一样可以保证线程安全:</p>
<blockquote>
<p><code>Semaphore</code>：就是信号量，可以控制同时访问特定资源的线程数量</p>
<p><code>CountDownLatch</code>：允许一个或多个线程等待其他线程完成操作 </p>
<p><code>CyclicBarrier</code>：让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续运行</p>
</blockquote>
<p>4.本地存储：我们也可以考虑使用<code>ThreadLocal</code>存储变量，<code>ThreadLocal</code>可以很方便地为每一个线程单独存一份数据，也就是将需要并发访问的资源复制成多份，就可以避免多线程访问共享变量了，它们访问的是自己独占的资源，它从根本上隔离了多个线程之间的数据共享</p>
</blockquote>
</li>
</ul>
<h4 id="ThreadLocal（作用、实现机制）"><a href="#ThreadLocal（作用、实现机制）" class="headerlink" title="ThreadLocal（作用、实现机制）"></a><code>ThreadLocal</code>（作用、实现机制）</h4><ul>
<li><p><code>ThreadLocal</code>，即线程变量，它将需要并发访问的资源复制多份，让每个线程拥有一份资源</p>
</li>
<li><p>作用：避免对变量进行同步操作（空间换时间）</p>
<blockquote>
<p>由于每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了</p>
<p><code>ThreadLocal</code>提供了<strong>线程安全的共享机制</strong>，在编写多线程代码时，可以把不安全的变量封装进<code>ThreadLocal</code></p>
</blockquote>
</li>
<li><p>实现机制</p>
<blockquote>
<p>在实现上，Thread类中声明了<code>threadLocals</code>变量，用于存放当前线程独占的资源</p>
<p><code>ThreadLocal</code>类中定义了该变量的类型（<code>ThreadLocalMap</code>），这是一个类似于Map的结构，用于存放键值对</p>
<p><code>ThreadLocal</code>类中还提供了set和get方法，set方法会初始化<code>ThreadLocalMap</code>并将其绑定到<code>Thread.threadLocals</code>，从而将传入的值绑定到当前线程在数据存储上，传入的值将作为键值对的value，<strong>而key则是<code>ThreadLocal</code>对象本身（this）</strong></p>
<p>get方法没有任何参数，它会以<strong>当前<code>ThreadLocal</code>对象（this）为key</strong>，从<code>Thread.threadLocals</code>中获取与当前线程绑定的数据</p>
</blockquote>
</li>
<li><p>注意：</p>
<blockquote>
<p><code>ThreadLocal</code>不能替代同步机制，两者面向的问题领域不同</p>
<p>同步机制是为了同步多个线程对相同资源的并发访问，是<strong>多个线程之间进行通信</strong>的有效方式</p>
<p>而<code>ThreadLocal</code>是为了<strong>隔离多个线程的数据共享</strong>，从根本上避免多个线程之间对共享资源（变量）的竞争，也就不需要对多个线程进行同步了</p>
<p>一般情况下，如果多个线程之间需要共享资源，以达到<strong>线程之间的通信功能</strong>，就使用<strong>同步机制</strong></p>
<p>如果仅仅需要<strong>隔离多个线程之间的共享冲突</strong>，则可以使用<code>ThreadLocal</code></p>
</blockquote>
</li>
</ul>
<h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><ul>
<li><p><code>java</code>线程同步的方式主要为加锁：<code>synchronized</code>和<code>Lock</code></p>
</li>
<li><p>synchronized：加锁有三种方式，区别是锁住的对象不同(没有考虑到超时机制、非阻塞形式、多个条件变量)</p>
<blockquote>
<p>加在普通方法上，则锁是当前的实例（this）</p>
<p>加在静态方法上，则锁是当前类的Class对象</p>
<p>加在代码块上，则需要在关键字后面的小括号里，显式指定一个对象作为锁对象</p>
<blockquote>
<p>synchronized采用<code>&quot;CAS + Mark Word&quot;</code>实现，为了性能的考虑，并通过锁升级机制降低锁的开销（Mark Word 存在于对象头中，保存有对象的monitor对象）</p>
<p>在并发环境中，synchronized会随着多线程竞争的加剧，逐步升级：无锁、偏向锁、轻量级锁、重量级锁</p>
</blockquote>
</blockquote>
</li>
<li><p><code>Lock</code>：支持响应<strong>中断</strong>、支持<strong>超时机制</strong>、支持以<strong>非阻塞的方式获取锁</strong>、支持<strong>多个条件变量</strong>（阻塞队列）</p>
<blockquote>
<p>Lock则采用<code>&quot;CAS + volatile&quot;</code>实现，其实现的核心是<code>AQS</code></p>
<p><code>AQS</code>是线程同步器，是一个线程同步的基础框架，它基于<strong>模板方法模式</strong></p>
<p>在具体的Lock实例中，锁的实现是通过<strong>继承<code>AQS</code>来实现</strong>的，并且可以根据锁的使用场景，派生出公平锁、不公平锁、读锁、写锁等具体的实现</p>
</blockquote>
</li>
</ul>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li><p>volatile是轻量级的synchronized</p>
<blockquote>
<p>volatile使用恰当的话，它比synchronized的执行成本更低，因为<strong>它不会引起线程上下文的切换和调度</strong></p>
<p><strong>它在多处理器开发中保证了共享变量的“可见性”</strong></p>
<p>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入</p>
<p>原子性：对单个volatile变量的读写具有原子性，对“volatile变量++”这种复合操作则不具有原子性</p>
<p><strong>禁止指令重排</strong></p>
<p>使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：</p>
<ul>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ul>
<p>即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行</p>
<p>且前面语句的结果对volatile变量及其后面语句可见</p>
<p>注意，虽然volatile能够保证可见性，但它不能保证原子性</p>
<p>volatile变量在各个线程的工作内存中是不存在一致性问题的，但是<strong>Java里面的运算操作符并非原子操作</strong>，这导致volatile变量的运算在并发下一样是不安全的</p>
</blockquote>
</li>
<li><p>读&#x2F;写内存语义</p>
<blockquote>
<p><code>JMM</code>是指Java内存模型，而本地内存只是<code>JMM</code>的一个抽象概念，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</p>
<p>写内存语义：当写一个volatile变量时，<code>JMM</code>会把该线程本地内存中的<strong>共享变量的值刷新到主内存中</strong></p>
<p>读内存语义：当读一个volatile变量时，<code>JMM</code>会把该<strong>线程本地内存置为无效</strong>，使其<strong>从主内存中读取共享变量</strong></p>
</blockquote>
</li>
<li><p>实现机制</p>
<blockquote>
<p> volatile的底层是<strong>采用内存屏障</strong>来实现的，就是在编译器生成字节码时，会在指令序列中插入内存屏障来<strong>禁止特定类型的处理器重排序</strong></p>
<p> 内存屏障就是一段与平台相关的代码，Java中的内存屏障代码都在Unsafe类中定义，共包含三个方法：<code>LoadFence()、storeFence()、fullFence()</code></p>
<p> 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：</p>
<p> 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</p>
<p> <strong>即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</strong></p>
<p> <strong>它会强制将对缓存的修改操作立即写入主存</strong></p>
<p> <strong>如果是写操作，它会导致其他CPU中对应的缓存行无效</strong></p>
</blockquote>
</li>
<li><p>volatile与锁的区别</p>
<blockquote>
<p>从内存语义的角度来说，volatile的读&#x2F;写，与锁的获取&#x2F;释放具有相同的内存效果</p>
<p><strong>volatile读</strong>与<strong>锁的获取</strong>有相同的内存语义，<strong>volatile写</strong>与<strong>锁的释放</strong>有相同的内存语义</p>
<p>volatile只<strong>能保证单个变量读写的原子性</strong>，而锁则可以<strong>保证对整个临界区的代码执行具有原子性</strong></p>
<p>在功能上锁比volatile更强大，在可伸缩性和性能上volatile更优优势</p>
</blockquote>
</li>
</ul>
<h4 id="synchronize的用法及原理"><a href="#synchronize的用法及原理" class="headerlink" title="synchronize的用法及原理"></a>synchronize的用法及原理</h4><ul>
<li><p>关键点：作用与三个位置的区别，与对象头的关系，锁升级</p>
<ul>
<li>作用位置：</li>
</ul>
<blockquote>
<p>作用在静态方法上，则锁是当前类的Class对象</p>
<p>作用在普通方法上，则锁是当前的实例（this）</p>
<p>作用在代码块上，则需要在关键字后面的小括号里，显式指定一个对象作为锁对象</p>
</blockquote>
<ul>
<li>对象头</li>
</ul>
<blockquote>
<p>原理 synchronized的底层是采用Java对象头来存储锁信息的，并且还支持锁升级</p>
<p>Java对象头包含三部分，分别是<code>Mark Word、Class Metadata Address、Array length</code></p>
<p>其中，Mark Word用来存储对象的<code>hashCode</code>及锁信息，<code>Class Metadata Address</code>用来存储对象类型的指针，而Array length则用来存储数组对象的长度，如果对象不是数组类型，则没有Array length信息</p>
<p>synchronized的锁信息包括<strong>锁的标志</strong>和<strong>锁的状态</strong>，这些信息都存放在对象头的<strong>Mark Word</strong>这一部分</p>
</blockquote>
<ul>
<li>锁升级</li>
</ul>
<blockquote>
<p>Java 6为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁</p>
<p>所以，在Java 6中，锁一共被分为4种状态，级别由低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</p>
<p>随着线程竞争情况的升级，锁的状态会从无锁状态逐步升级到重量级锁状态</p>
<p>锁可以升级却不能降级，这种只能升不能降的策略，是为了提高效率</p>
<p>锁升级的过程：</p>
<blockquote>
<p>开始，没有任何线程访问同步块，此时同步块处于无锁状态</p>
<p>然后，线程1首先访问同步块，它<strong>以<code>CAS</code>的方式修改Mark Word</strong>，尝试加偏向锁</p>
<p>由于此时没有竞争，所以偏向锁加锁成功，此时Mark Word里存储的是线程1的ID</p>
<p>然后，线程2开始访问同步块，它以<code>CAS</code>的方式修改Mark Word，尝试加偏向锁</p>
<p>由于此时存在竞争，所以偏向锁加锁失败，于是线程2会<strong>发起撤销偏向锁的流程</strong>（清空线程1的ID），于是同步块从偏向线程1的状态<strong>恢复到了可以公平竞争的状态</strong></p>
<p>然后，线程1和线程2共同竞争，它们同时以<code>CAS</code>方式修改Mark Word，尝试加轻量级锁</p>
<p>由于存在竞争，只有一个线程会成功，假设线程1成功了。但线程2不会轻易放弃，它认为线程1很快就能执行完毕，执行权很快会落到自己头上，于是线程2继续<strong>自旋加锁</strong></p>
<p>最后，如果线程1很快执行完，则线程2就会加轻量级锁成功，锁不会晋升到重量级状态</p>
<p>也可能是线程1执行时间较长，那么线程2<strong>自旋一定次数后就放弃自旋</strong>，并<strong>发起锁膨胀的流程</strong></p>
<p>届时，锁被线程2修改为重量级锁，之后线程2进入阻塞状态</p>
<p>而线程1重复加锁或者解锁时，<code>CAS</code>操作都会失败，此时它就会释放锁并唤醒等待的线程</p>
<p>总之，在锁升级的机制下，锁不会一步到位变为重量级锁，而是根据竞争的情况逐步升级的</p>
<p>当竞争小的时候，只需以较小的代价加锁，直到竞争加剧，才使用重量级锁，从而减小了加锁带来的开销</p>
</blockquote>
</blockquote>
<ul>
<li><p>偏向锁</p>
<blockquote>
<p>偏向锁，顾名思义就是锁偏向于某一个线程</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里<strong>存储锁偏向的线程ID</strong>，以后该线程再进入和退出同步块时就不需要做加锁和解锁操作了，只需要简单地测试一下Mark Word里是否存储着自己的线程ID即可</p>
</blockquote>
</li>
<li><p>轻量级锁</p>
<blockquote>
<p>轻量级锁，就是加锁时<code>JVM</code>先在当前线程栈帧中创建用于存储锁记录的空间，并将Mark Word复制到锁记录中，官方称之为Displaced Mark Word</p>
<p>然后线程尝试以<code>CAS</code>方式<strong>将Mark Word替换为指向锁记录的指针</strong>，如果成功则当前线程获得锁，如果失败则表示其他线程竞争锁，此时当前线程就会通过自旋来尝试获取锁</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="synchronized和Lock区别"><a href="#synchronized和Lock区别" class="headerlink" title="synchronized和Lock区别"></a>synchronized和Lock区别</h4><ul>
<li><p>synchronized和Lock都是锁，都是线程同步的手段</p>
</li>
<li><p>使用方式</p>
<blockquote>
<blockquote>
<p><strong>synchronized是Java关键字，在JVM层面实现加锁和解锁</strong></p>
<p>synchronized关键字可以作用在静态方法、实例方法和代码块上，它是一种<strong>隐式锁</strong>，即我们无需<strong>显式地获取和释放锁</strong></p>
<p>synchronized会导致线程拿不到锁一直等待</p>
<p>synchronized无法得知是否获取锁成功</p>
<p>synchronized锁可重入、不可中断、非公平</p>
<p>需要依赖<strong>Monitor（同步监视器）来实现线程通信</strong></p>
<p>作用在静态方法上，则Monitor就是当前类的Class对象</p>
<p>作用在实例方法上，则Monitor就是当前实例（this）</p>
<p>作用在代码块上，则需要在关键字后面的小括号里显式指定一个对象作为Monitor</p>
</blockquote>
<blockquote>
<p>Lock是一个接口，在<strong>代码层面实现加锁和解锁</strong></p>
<p>Lock则可以通过tryLock得知加锁是否成功</p>
<p>Lock接口是<strong>显式锁</strong>，即我们需要<strong>调用其内部定义的方法显式地加锁和解锁</strong>，相对于synchronized来说这显得有些繁琐，但是却提供了更大的灵活性</p>
<p>Lock锁可重入、可中断、可公平&#x2F;不公平，并可以细分读写锁以提高效率</p>
<p>需要<strong>依赖Condition对象来实现线程通信</strong>，该对象是由<strong>Lock对象创建</strong>出来的，依赖于Lock</p>
<p>每个Condition代表一个<strong>等待队列</strong>，而一个Lock可以<strong>创建多个Condition对象</strong></p>
</blockquote>
<blockquote>
<p>每个<strong>Monitor也代表一个等待队列</strong>，但synchronized<strong>只能有一个Monitor</strong></p>
<p>在实现线程通信方面，Lock接口具备更大的灵活性</p>
</blockquote>
</blockquote>
</li>
<li><p>特性</p>
<blockquote>
<p> synchronized是早期的<code>API</code>，Lock则是在<code>JDK 1.5</code>时引入的</p>
<p>Lock弥补了synchronized的不足，它新增了一些特性</p>
<blockquote>
<p>可中断地获取锁：线程在获取锁的过程中可以被中断</p>
<p>非阻塞地获取锁：该方法在调用后立刻返回，若能取到锁则返回true，否则返回false</p>
<p>可超时地获取锁：若线程在到达超时时间后仍未获得锁，并且线程也没有被中断，则返回false</p>
</blockquote>
</blockquote>
</li>
<li><p>实现机制</p>
<blockquote>
<blockquote>
<p>synchronized的底层是采用Java对象头来存储锁信息的（对象头具体见<strong>synchronize的用法及原理</strong>）</p>
</blockquote>
<blockquote>
<p><code>AQS</code>是队列同步器，是用来构建锁的基础框架，Lock实现类都是基于<code>AQS</code>实现的</p>
<p><code>AQS</code>是基于模板方法模式进行设计的，所以锁的实现需要继承<code>AQS</code>并重写它指定的方法</p>
<p><code>AQS</code>内部定义了一个FIFO的队列来实现线程的同步，同时还定义了同步状态来记录锁的信息</p>
</blockquote>
</blockquote>
</li>
<li><p>性能</p>
<blockquote>
<p>早期的synchronized性能较差，不如Lock</p>
<p>后来synchronized在实现上引入了<strong>锁升级机制（见synchronize的用法及原理）</strong>，性能上已经不输给Lock</p>
<p>synchronized和Lock的区别主要不在性能上，二者性能相差无几</p>
</blockquote>
</li>
<li><p>Lock拓展</p>
<blockquote>
<p>Lock接口的经典实现是<strong>ReentrantLock</strong>，还有<strong>ReadWriteLock接口</strong>，它的内部设计了两把锁分别用于读写，这两把锁都是Lock类型，它的经典实现是<strong>ReentrantReadWriteLock</strong></p>
<p>ReentrantLock<strong>通过内部类Sync定义了锁</strong>，它还<strong>定义了Sync的两个子类FrSync和NonfrSync</strong>，这两个子类分别代表<strong>公平锁和非公平锁</strong></p>
<p><strong>Sync继承自AQS</strong>，它不仅仅使用AQS的同步状态记录锁的信息，还利用同步状态记录了重入次数</p>
<p>同步状态是一个整数，当它为0时代表无锁，当它为N时则代表线程持有锁并重入了N次</p>
<p>ReentrantReadWriteLock支持重入的方式与ReentrantLock一致，它也定义了内部类Sync，并定义出两个子类FrSync和NonfrSync来实现公平锁和非公平锁</p>
<p>ReentrantReadWriteLock内部包<strong>含读和写两把锁</strong>，这两把锁都是<strong>由Sync来实现</strong>的</p>
<p>区别在于<strong>读锁支持共享</strong>，即<strong>多个线程可以同时加读锁成功</strong>，而<strong>写锁是互斥</strong>的，即只能有一个线程加锁成功</p>
</blockquote>
</li>
</ul>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><blockquote>
<p><code>AQS</code>（<code>AbstractQueuedSynchronizer</code>）是<strong>队列同步器</strong>，是用来构建锁的基础框架，<strong>Lock实现类都是基于<code>AQS</code>实现的</strong></p>
<p><code>AQS</code>是基于<strong>模板方法模式</strong>进行设计的，所以锁的实现需要继承<code>AQS</code>并重写它指定的方法</p>
<p><code>AQS</code>内部定义了一个<strong>FIFO的队列</strong>来实现线程的同步，同时还定义了<strong>同步状态来记录锁的信息</strong></p>
<p><code>AQS</code>的模板方法，将管理同步状态的逻辑提炼出来形成标准流程，这些方法主要包括：<strong>独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态</strong></p>
</blockquote>
<ul>
<li>以独占式获取同步状态为例，它的大致流程是：</li>
</ul>
<blockquote>
<p>尝试以独占方式获取同步状态</p>
<p>如果状态获取失败，则将当前线程加入同步队列</p>
<p>自旋处理同步状态，如果当前线程位于队头，则唤醒它并让它出队，否则使其进入阻塞状态</p>
<p>其中，有些步骤无法在父类确定，则提炼成空方法留待子类实现</p>
<p>例如，第一步的尝试操作，对于公平锁和非公平锁来说就不一样，所以子类在实现时需要按照场景各自实现这个方法</p>
<p><code>AQS</code>的同步队列，是一个双向链表，<code>AQS</code>则持有链表的头尾节点</p>
<p>对于尾节点的设置，是存在多线程竞争的，所以<strong>采用<code>CAS</code>的方式进行修改</strong></p>
<p>对于头节点设置，则一定是拿到了同步状态的线程才能处理，所以修改头节点不需要采用<code>CAS</code>的方式</p>
<p><code>AQS</code>的同步状态，是一个int类型的整数，它在表示状态的同时还能表示数量</p>
<p>通常情况下，状态为0时表示无锁，状态大于0时表示锁的重入次数</p>
<p>另外，在读写锁的场景中，这个状态标志既要记录读锁又要记录写锁</p>
<p>于是，锁的实现者就将状态表示拆成高低两部分，高位存读锁，低位存写锁</p>
<p><strong>同步状态</strong>需要在并发环境下修改，所以需要<strong>保证其线程安全</strong></p>
<p>由于<code>AQS</code>本身就是锁的实现工具，所以不适合用锁来保证其线程安全，因为如果你用一个锁来定义另一个锁的话，那干脆直接用synchronized算了</p>
<p>实际上，同步状态是被<strong>volatile修饰</strong>的，该关键字可以保证状态变量的内存可见性，从而解决了线程安全问题</p>
</blockquote>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><ul>
<li><p>CAS是Compare and Swap的缩写，翻译过来就是比较并替换</p>
</li>
<li><p>CAS机制</p>
<blockquote>
<p>使用了3个基本操作数：</p>
<p>内存地址V，旧的预期值A，要修改的新值B</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</p>
</blockquote>
</li>
<li><p>CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新</p>
</li>
<li><p>缺点：</p>
<blockquote>
<p>CPU开销过大</p>
<p>不能保证代码块的原子性</p>
<p>ABA机制问题</p>
<p>当一个值从A变成B，又更新回A，普通CAS机制会误判通过检测</p>
<p>利用版本号比较可以有效解决ABA问题</p>
</blockquote>
</li>
<li><p>java语言CAS底层如何实现？</p>
</li>
</ul>
<blockquote>
<p>利用unsafe提供的原子性操作方法</p>
</blockquote>
<ul>
<li><p>应用场景</p>
<blockquote>
<p>对于原子类</p>
<blockquote>
<p>以<code>AtomicInteger</code>为例，它的内部提供了诸多原子操作的方法</p>
<p>如原子替换整数值、增加指定的值、加1，这些方法的底层便是采用操作系统提供的<code>CAS</code>原子指令来实现的</p>
</blockquote>
<p>对于<code>AQS</code></p>
<blockquote>
<p>在向同步队列的尾部追加节点时，它首先会以<code>CAS</code>的方式尝试一次，如果失败则进入自旋状态，并反复以<code>CAS</code>的方式进行尝试</p>
<p>此外，在以共享方式释放同步状态时，它也是以<code>CAS</code>方式对同步状态进行修改的</p>
</blockquote>
<p>对于并发容器</p>
<blockquote>
<p>以<code>ConcurrentHashMap</code>为例，它的内部多次使用了<code>CAS</code>操作</p>
<p>在初始化数组时，它会以<code>CAS</code>的方式修改初始化状态，避免多个线程同时进行初始化在执行put方法初始化头节点时，它会以<code>CAS</code>的方式将初始化好的头节点设置到指定槽的首位，避免多个线程同时设置头节点</p>
<p>在数组扩容时，每个线程会以<code>CAS</code>方式修改任务序列号来争抢扩容任务，避免和其他线程产生冲突</p>
<p>在执行get方法时，它会以<code>CAS</code>的方式获取头指定槽的头节点，避免其他线程同时对头节点做出修改。 </p>
<p><code>CAS</code>的实现离不开操作系统原子指令的支持，Java中对原子指令封装的方法集中在Unsafe类中，包括：原子替换引用类型、原子替换int型整数、原子替换long型整数这些方法都有四个参数：<code>var1、var2、var4、var5</code>，其中<code>var1</code>代表要操作的对象，<code>var2</code>代表要替换的成员变量的地址，<code>var4</code>代表期望的值，<code>var5</code>代表更新的值</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">( Object var1， <span class="type">long</span> var2， Object var4， Object var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">( Object var1， <span class="type">long</span> var2， <span class="type">int</span> var4， <span class="type">int</span> var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">( Object var1， <span class="type">long</span> var2， <span class="type">long</span> var4， <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
</li>
</ul>
<h4 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h4><ul>
<li><p>常用的线程通信方式有两种，分别是利用Monitor实现线程通信、利用Condition实现线程通信</p>
<blockquote>
<p>线程同步是线程通信的前提，所以究竟采用哪种方式实现通信，取决于线程同步的方式</p>
<blockquote>
<p>采用synchronized关键字进行同步，则需要依赖Monitor（同步监视器）实现线程通信，Monitor就是锁对象</p>
<p>在synchronized同步模式下，<strong>锁对象可以是任意的类型</strong>，所以<strong>通信方法自然就被定义在Object类中</strong>了，这些方法包括：**<code>wt()、notify()、notifyAll()</code>**</p>
<p>一个线程通过Monitor调用wt()时，它就会<strong>释放锁</strong>并在此等待</p>
<p>当其他线程通过Monitor调用<code>notify()</code>时，则会唤醒在此等待的一个线程</p>
<p>当其他线程通过Monitor调用<code>notifyAll()</code>时，则会唤醒在此等待的所有线程</p>
<p><strong>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列</strong></p>
<p>就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程</p>
<p>当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度</p>
<p>反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒</p>
</blockquote>
<blockquote>
<p>采用Lock对象进行同步，则需要依赖Condition实现线程通信，Condition对象是由Lock对象创建出来的，它依赖于Lock对象</p>
<p>Condition对象中定义的通信方法，与Object类中的通信方法类似，它包括**<code>awt()、signal()、signalAll()</code>**</p>
<p>通过名字就能看出它们的含义了，当通过Condition调用<code>awt()</code>时当前线程<strong>释放锁并等待</strong>，当通过Condition调用<code>signal()</code>时唤醒一个等待的线程，当通过Condition调用<code>signalAll()</code>时则唤醒所有等待的线程</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="wt-和sleep"><a href="#wt-和sleep" class="headerlink" title="wt()和sleep()"></a>wt()和sleep()</h4><ul>
<li><p>相同点</p>
<blockquote>
<p>都是作用于线程，使线程终止当前运行状态</p>
</blockquote>
</li>
<li><p>不同点</p>
<blockquote>
<blockquote>
<p>wt()属于Object类的实例方法，它会使线程进入WAITING（等待状态）</p>
<p>它<strong>依赖于synchronized锁</strong>，必须<strong>通过监视器进行调用</strong>，在调用后线程会释放锁</p>
<p>调用wt()进入等待状态的线程，需要其他线程调用notify()或notifyAll()来返回</p>
</blockquote>
<blockquote>
<p>sleep()属于Thread类的静态方法，它会使线程进入TIMED_WAITING（超时等待状态）</p>
<p>sleep()不依赖于任何锁，调用后也不会释放当前持有的锁</p>
<p>sleep()可以在任何地方使用，而<strong>wait()只能在同步方法或同步代码块中使用</strong></p>
<p>在超时时间到达后自动返回</p>
</blockquote>
</blockquote>
</li>
<li><p>注：</p>
<blockquote>
<p><strong>wt()方法也支持超时参数</strong>，线程调用带有超时参数的wt()会进入TIMED_WTING状态，在此状态下的线程可以通过notify()&#x2F;notifyAll()唤醒从而返回，若在达到超时时间后仍然未被唤醒则自动返回</p>
<p>如果采用Lock进行线程同步，则不存在同步监视器，此时需要使用Condition的方法实现等待</p>
<p>Condition对象是通过Lock对象创建出来的，它的awt()方法会导致线程进入WTING状态，它的带超时参数的awt()方法会导致线程进入TIMED_WTING状态，当调用它的signal()&#x2F;signalAll()方法时，线程会被唤醒从而返回</p>
</blockquote>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote>
<p>Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型</p>
<p>例如 Person p &#x3D; new Student()</p>
<p>这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student</p>
<p>有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法</p>
<p>这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：</p>
<ul>
<li>第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可</li>
<li>第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射</li>
</ul>
</blockquote>
<ul>
<li><p>概念：程序运行时，在不知道某对象属于哪个类的情况下，程序通过运行时信息来发现该对象和类的真实信息，这就必须用到反射</p>
</li>
<li><p>应用：</p>
<blockquote>
<p>程序运行时，可以通过反射<strong>获得任意一个类的Class对象，并通过这个对象查看这个类的信息</strong></p>
<p>程序运行时，可以通过反射<strong>创建任意一个类的实例，并访问该实例的成员</strong></p>
<p>程序运行时，可以通过反射机制<strong>生成一个类的动态代理类或动态代理对象</strong></p>
<p>使用<code>JDBC</code>时，如果要创建数据库的连接，则需要先通过反射机制<strong>加载数据库的驱动程序</strong></p>
<p>多数框架都支持注解&#x2F;XML配置，从配置中<strong>解析出来的类是字符串</strong>，需要利用反射机制<strong>实例化</strong></p>
<p>面向切面编程（<code>AOP</code>）的实现方案，是在程序运行时<strong>创建目标对象的代理类</strong>，这必须由反射机制来实现</p>
</blockquote>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>Java中的集合类分为4大类，分别由4个接口来代表，它们是Set、List、Queue、Map</p>
<blockquote>
<p>其中，Set、List、Queue都继承自Collection接口</p>
<p>Set代表无序的、元素不可重复的集合</p>
<p>List代表有序的、元素可以重复的集合</p>
<p>Queue代表先进先出（FIFO）的队列</p>
<p>Map代表具有映射关系（key-value）的集合</p>
<p> Java提供了众多集合的实现类，它们都是这些接口的直接或间接的实现类，其中比较常用的有：<code>HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap</code>等</p>
</blockquote>
<blockquote>
<p>上面所说的集合类的接口或实现，都位于<code>java.util</code>包下，这些实现大多数都是非线程安全的，但是这些类的性能较好</p>
<p>如果需要使用线程安全的集合类，可以参考<strong>线程安全的集合</strong></p>
</blockquote>
</li>
</ul>
<h4 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h4><ul>
<li>List和Set都是Collection接口的子接口，它们的主要区别在于元素的有序性和重复性</li>
</ul>
<blockquote>
<blockquote>
<p>List代表有序的元素可以重复的集合，集合中<strong>每个元素都有对应的顺序索引</strong>，它<strong>默认按元素的添加顺序设置元素的索引</strong>，并且可以通过索引来访问指定位置的集合元素</p>
<p>List允许使用重复元素</p>
</blockquote>
<blockquote>
<p>Set代表无序的元素不可重复的集合，它通常<strong>不能记住元素的添加顺序</strong></p>
<p>Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set，则会引发失败，添加方法将会返回false</p>
</blockquote>
<blockquote>
<p>Set代表无序的集合，但是它有支持排序的实现类，即TreeSet</p>
<p>TreeSet可以确保集合元素处于排序状态，并支持<strong>自然排序</strong>和<strong>定制排序</strong>两种排序方式，它的底层是由TreeMap实现的</p>
<p>TreeSet也是非线程安全的，但是它内部元素的值不能为null</p>
</blockquote>
</blockquote>
<h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><ul>
<li>数据结构：<ul>
<li><code>ArrayList</code>：实现基于数组</li>
<li><code>LinkedList</code>：实现基于双向链表</li>
</ul>
</li>
<li>访问数据<ul>
<li><code>ArrayList</code>：可以根据下标以O(1)时间复杂度对元素进行随机访问</li>
<li><code>LinkedList</code>：只能通过从头指针或尾指针遍历整个列表来访问某个特定元素</li>
</ul>
</li>
<li>插入or删除<ul>
<li><code>ArrayList</code>：涉及到数组扩容，数据移动，更新索引等效率相对较低</li>
<li><code>LinkedList</code>：可以通过直接更改前后指针所指向的元素，达到插入or删除的目的，效率较高</li>
</ul>
</li>
<li>存储<ul>
<li><code>ArrayList</code>：只需要存储数据</li>
<li><code>LinkedList</code>：节点除了存储数据之外还需要存储两个引用，分别指向前一个节点和后一个节点</li>
</ul>
</li>
</ul>
<h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><ul>
<li><p>数据结构：</p>
<blockquote>
<p>HashMap、HashTable底层实现都是哈希表 数组 + 链表 + 红黑树</p>
</blockquote>
</li>
<li><p>key&#x2F;value限制</p>
<blockquote>
<p>HashTable的key，value均不能为null</p>
<p>HashMap没有限制</p>
</blockquote>
</li>
<li><p>线程安全</p>
<blockquote>
<p>HashTable线程安全</p>
<p>HashMap不保证线程安全</p>
</blockquote>
</li>
<li><p>性能</p>
<blockquote>
<p>HashTable由于保证线程安全，牺牲了一些性能</p>
<p>对比之下HashMap性能更高</p>
</blockquote>
</li>
<li><p>注意</p>
<blockquote>
<p>虽然Hashtable是线程安全的，但仍然不建议在多线程环境下使用Hashtable</p>
<p>因为它是一个古老的API，从Java 1.0开始就出现了，它的同步方案还不成熟，性能不好</p>
<p>如果要在多线程环下使用HashMap，建议使用ConcurrentHashMap</p>
<p>它不但保证了线程安全，也通过降低锁的粒度提高了并发访问时的性能</p>
</blockquote>
</li>
</ul>
<h4 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h4><ul>
<li><p><code>java.util</code></p>
<ul>
<li><p><code>Vector</code></p>
</li>
<li><p><code>HashTable</code></p>
</li>
<li><p>对于这个包下非线程安全的集合，可以利用Collections工具类，该工具类提供的<code>synchronizedXxx()</code>方法，可以将这些集合类包装成线程安全的集合类</p>
</li>
</ul>
</li>
<li><p><code>java.util.concurrent (JUC)</code> : 从<code>JDK 1.5</code>开始，并发包下新增了大量高效的并发的容器，这些容器按照实现机制可以分为三类</p>
<ul>
<li><p>以降低锁粒度来提高并发性能的容器，它们的类名以<code>Concurrent</code>开头，如<code>ConcurrentHashMap</code></p>
</li>
<li><p>采用写时复制技术实现的并发容器，它们的类名以<code>CopyOnWrite</code>开头，如<code>CopyOnWriteArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部有一个Object[] array，初始化大小为零，在设置或添加元素时，先对集合内部的Object对象加锁，然后对数组进行复制，在数组副本上进行操作，然后把数组副本赋给array</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            Object[] es = getArray();</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementAt(es, index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">                es = es.clone();</span><br><span class="line">                es[index] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Ensure volatile write semantics even when oldvalue == element</span></span><br><span class="line">            setArray(es);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            Object[] es = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">            es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">            es[len] = e;</span><br><span class="line">            setArray(es);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>采用Lock实现的阻塞队列，内部创建两个<code>Condition</code>分别用于生产者和消费者的等待，这些类都实现了<code>BlockingQueue</code>接口，如<code>ArrayBlockingQueue</code></p>
</li>
</ul>
</li>
<li><p>通过Collections提供的三类方法，可以生成“只读”的Collection或Map</p>
<ul>
<li><p><code>emptyXxx()</code>：返回一个空的不可变的集合对象</p>
</li>
<li><p><code>singletonXxx()</code>：返回一个只包含指定对象的不可变的集合对象</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> E element;</span><br><span class="line">SingletonList(E obj)&#123;element = obj;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>unmodifiableXxx()</code>：返回指定集合对象的不可变视图</p>
<blockquote>
<p>返回的集合只能对元素进行读取，任何写操作都会抛出异常</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li><p>数据结构：ArrayList是基于数组实现的，它的内部封装了一个Object[]数组</p>
</li>
<li><p>创建</p>
<blockquote>
<p>通过默认构造器创建容器时，该数组先被初始化为空数组，之后在<strong>首次添加数据</strong>时再将其<strong>初始化</strong>成长度为10的数组</p>
<p>我们也可以使用有参构造器来创建容器，并通过参数来显式指定数组的容量，届时该<strong>数组被初始化为指定容量</strong>的数组</p>
</blockquote>
</li>
<li><p>扩容</p>
<blockquote>
<p>如果向ArrayList中添加数据会造成超出数组长度限制，则会触发自动扩容，然后再添加数据</p>
<p>扩容就是数组拷贝，将旧数组中的数据拷贝到新数组里，而新数组的长度为原来长度的<strong>1.5</strong>倍</p>
<p>ArrayList支持缩容，但不会自动缩容，即便是ArrayList中只剩下少量数据时也不会主动缩容</p>
<p>如果我们希望<strong>缩减ArrayList的容量</strong>，则需要自己调用它的**trimToSize()**方法，届时数组将按照元素的实际个数进行缩减</p>
</blockquote>
</li>
<li><p>与其他集合类对比</p>
<blockquote>
<p>Set、List、Queue都是Collection的子接口，它们都继承了父接口的iterator()方法，从而具备了迭代的能力</p>
<p>但是，相比于另外两个接口，List还单独提供了listIterator()方法，增强了迭代能力</p>
<p>iterator()方法返回Iterator迭代器，listIterator()方法返回ListIterator迭代器，并且ListIterator是Iterator的子接口</p>
<p>ListIterator在Iterator的基础上，增加了<strong>向前遍历</strong>的支持，增加了在<strong>迭代过程中修改数据的支持</strong></p>
</blockquote>
</li>
</ul>
<h4 id="ConcurrentHashMap（JDK-1-8）"><a href="#ConcurrentHashMap（JDK-1-8）" class="headerlink" title="***ConcurrentHashMap（JDK 1.8）"></a>***ConcurrentHashMap（JDK 1.8）</h4><ul>
<li><p>数据结构：数组 + 链表 + 红黑树</p>
</li>
<li><p>锁的粒度：采用锁定链表或红黑树的头节点（数组的每个槽）（Synchronized 和 CAS 来操作）</p>
</li>
<li><p>线程安全实现机制：</p>
<blockquote>
<p>初始化数组或头节点时，<code>ConcurrentHashMap</code>并没有加锁，而是<code>CAS</code>的方式进行原子替换（原子操作，基于Unsafe类的原子操作<code>API</code>）</p>
<p><strong>插入数据</strong>时会进行<strong>加锁处理</strong>，但锁定的不是整个数组，而是槽中的头节点，所以，<code>ConcurrentHashMap</code>中锁的粒度是槽，而不是整个数组，并发的性能很好</p>
<p><strong>扩容</strong>时会进行<strong>加锁处理</strong>，锁定的仍然是头节点，并且，支持多个线程同时对数组扩容，提高并发能力，每个线程需先以<code>CAS</code>操作抢任务，争抢一段连续槽位的数据转移权，抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里</p>
<p><strong>查找数据</strong>时并<strong>不会加锁</strong>，所以性能很好，另外，在扩容的过程中，依然可以支持查找操作，如果某个槽还未进行迁移，则直接可以从旧数组里找到数据，如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点存入旧数组，届时查找线程根据转发节点的提示，从新数组中找到目标数据</p>
<p><code>ConcurrentHashMap</code>实现线程安全的难点在于<strong>多线程并发扩容</strong>，即当一个线程在插入数据时，若发现数组正在扩容，那么它就会立即参与扩容操作，完成扩容后再插入数据到新数组</p>
<p>在扩容的时候，<strong>多个线程共同分担数据迁移任务</strong>，每个线程负责的迁移数量是 <code>(数组长度 &gt;&gt;&gt; 3) / CPU核心数</code>，也就是说，为线程分配的迁移任务，是充分考虑了硬件的处理能力的，多个线程依据硬件的处理能力，平均分摊一部分槽的迁移工作，另外，如果计算出来的迁移数量小于16，则强制将其改为16，这是考虑到目前服务器领域主流的CPU运行速度，每次处理的任务过少，对于CPU的算力也是一种浪费</p>
</blockquote>
<blockquote>
<p>put操作流程</p>
<p>首先判断table是否已经初始化，没有则通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">            <span class="comment">//判断tab是否已经初始化，否，则调用initTable()进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//若已初始化则判断key的hash所对应的槽是否为空，为空则直接创建新节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//对头节点进行生成时，采用的也是CAS的机制实现的</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若槽不为空则判断头节点是否为转移节点，是则调用helpTransfer(tab, f)方法帮组转移旧table，参与槽位的争夺而不是当前头节点所在槽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="comment">//如果不是转移节点，则判断该头节点是否加锁、头节点key、value相等是否同时成立</span></span><br><span class="line">            <span class="comment">//成立则直接返回该节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                     &amp;&amp; fh == hash</span><br><span class="line">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                     &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> fv;</span><br><span class="line">            <span class="comment">//上述条件均不成立，则对头节点进行加锁，开始对链表 </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//头节点hash值大于等于0表示当前为链表，利用链表逻辑进行插入</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当头节点hash为-2时表示为红黑树结构，判断是否为树结构</span></span><br><span class="line">                        <span class="comment">//是则采用树的数据插入方式插入</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前槽位元素个数，如果满足树化条件则进行树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//使元素数量+1，在方法体内部进行是否扩容，扩容时,创建新的容量的table后，调用transfer(oldtable,newtable)方法进行元素转移，不同线程使用CAS的方式争夺槽位，然后再进行加锁移动元素</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">//采用CAS进行对数组进行初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>JDK 1.7</p>
<blockquote>
<p>JDK 1.7中的实现：</p>
<p>在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性</p>
<p>Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构</p>
</blockquote>
<blockquote>
<p>在JDK 7中ConcurrentHashMap的底层数据结构为“数组+链表”，但是为了降低锁的粒度，JDK7将一个Map拆分为若干子Map，每一个子Map称为一个段</p>
<p>多个段之间是相互独立的，而每个段都包含若干个槽，段中数据发生碰撞时采用链表结构解决</p>
<p>在并发插入数据时，ConcurrentHashMap<strong>锁定的是段</strong>，而不是整个Map，因为锁的粒度是段，所以这种模式也叫“<strong>分段锁</strong>”</p>
<p>另外，段在容器初始化的时候就被确定下来了，之后不能更改，而每个段是可以独立扩容的，各个段之间互不影响，所以并不存在并发扩容的问题</p>
</blockquote>
<blockquote>
<p>get操作：</p>
<p>Segment的get操作实现非常简单和高效，先经过一次再散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素</p>
<p>get操作的高效之处在于整个get过程都不需要加锁，除非读到空的值才会加锁重读</p>
<p>原因就是将使用的共享变量定义成 volatile 类型</p>
<p>put操作：</p>
<p>当执行put操作时，会经历两个步骤：</p>
<p>判断是否需要扩容</p>
<p>定位到添加元素的位置，将其放入 HashEntry 数组中</p>
<p>插入过程会进行第一次 key 的 hash 来定位 Segment 的位置，如果该 Segment 还没有初始化，即通过 CAS 操作进行赋值，然后进行第二次 hash 操作，找到相应的 HashEntry 的位置，这里会利用继承过来的锁的特性，在将数据插入指定的 HashEntry 位置时（尾插法），会通过继承 ReentrantLock 的 tryLock() 方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用 tryLock() 方法去获取锁，超过指定次数就挂起，等待唤醒</p>
</blockquote>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="***HashMap"></a>***HashMap</h4><ul>
<li><p>数据结构：数组 + 链表 + 红黑树(<code>jdk 1.8</code>)</p>
</li>
<li><p>插入</p>
<blockquote>
<p><code>HashMap</code>是基于哈希算法来确定元素的位置（槽）的，当我们向集合中存入数据时，它会计算传入的Key的哈希值，并利用<strong>哈希值取余</strong>来确定槽的位置</p>
<p>如果元素发生碰撞，也就是这个槽已经存在其他的元素了，则<code>HashMap</code>会通过链表将这些元素组织起来</p>
<p>如果碰撞进一步加剧，某个链表的长度达到了8，且数组容量达到了64，则<code>HashMap</code>会创建红黑树来代替这个链表，从而提高对这个槽中数据的查找的速度</p>
<p>put()流程</p>
<blockquote>
<p>判断数组是否为空，为空则进行首次扩容</p>
<p>根据key的hash值，找到数组对应位置，若头节点为空，则新建链表节点，存入数组</p>
<p>若发现头节点不为空，则将元素插入槽内</p>
<blockquote>
<p>key与头节点一致，则覆盖头节点</p>
<p>若元素为树型节点，则将元素追加到树中</p>
<p>若元素为链表节点，则将元素追加到链表中，并进行判断链表是否要转换为红黑树</p>
<p>若<strong>链表长度达到8</strong>、<strong>数组容量未达到64</strong>，则<strong>扩容</strong></p>
<p>若链表长度达到8、数组容量达到64，则转为<strong>红黑树</strong></p>
</blockquote>
<p> 插入元素后，判断元素的个数，若发现超过阈值则再次扩容</p>
</blockquote>
</blockquote>
</li>
<li><p>扩容机制</p>
<ul>
<li><p>触发扩容的三种条件</p>
<blockquote>
<p> 如果数组为空，则进行首次扩容</p>
<p>将元素接入链表后，如果链表长度达到8，并且数组长度小于64，则扩容</p>
<p>添加后，如果数组中元素超过阈值，即比例超出限制（默认为0.75），则扩容</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>HashMap</code>中，数组的默认初始容量为16，这个容量会以2的指数进行扩容</p>
<p>具体来说，当数组中的元素达到一定比例的时候<code>HashMap</code>就会扩容，这个比例叫做负载因子，默认为<strong>0.75</strong></p>
<p>自动扩容机制，是为了保证<code>HashMap</code>初始时不必占据太大的内存，而在使用期间又可以实时保证有足够大的空间</p>
<p>每次扩容时都是将容量翻倍，即创建一个2倍大的新数组，然后再将旧数组中的数组迁移到新数组里</p>
<p>由于<code>HashMap</code>中数组的容量为2^N，所以可以用位移运算计算新容量，效率很高</p>
</blockquote>
</li>
<li><p>线程不安全</p>
<blockquote>
<p><code>HashMap</code>是<strong>非线程安全</strong>的，在多线程环境下，多个线程同时触发<code>HashMap</code>的改变时，有可能会发生冲突</p>
<p>所以，在多线程环境下不建议使用<code>HashMap</code>，可以考虑使用<code>Collections</code>将<code>HashMap</code>转为线程安全的<code>HashMap</code>，更为推荐的方式则是使用<code>ConcurrentHashMap</code></p>
</blockquote>
</li>
<li><p>jdk 7和jdk 1.8中hashmap的区别</p>
<blockquote>
<p>JDK7中的HashMap，是基于数组+链表来实现的，它的底层维护一个Entry数组</p>
<p>它会根据计算的hashCode将对应的KV键值对存储到该数组中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时便形成了一个链表式的存储结构</p>
<p>JDK7中HashMap的实现方案有一个明显的缺点，即当Hash冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低，其时间复杂度为O(N)</p>
</blockquote>
<blockquote>
<p>JDK8中的HashMap，是基于数组+链表+红黑树来实现的，它的底层维护一个Node数组</p>
<p>当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构</p>
<p>这么做主要是在查询的时间复杂度上进行优化，链表为O(N)，而红黑树一直是O(logN)，可以大大的提高查找性能</p>
</blockquote>
</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="**泛型"></a>**泛型</h4><blockquote>
<p>在没有引入泛型之前，集合类中元素默认存放在Object对象数组中，不论放入什么类型的对象都一律当作Object存储，集合类这样设计的原因是，设计者不知道我们会往集合存放什么类型的对象，所以允许向集合中存放任意对象的实例，保证了集合的通用性，这样导致了一些问题</p>
<p>当我们想要用一个集合专门存放某一种类型的对象时，其他类型的对象也能轻易的被加入集合中</p>
<p>当我们取出对象来使用时，需要做强制类型转换，这增加了编程复杂度，还有可能导致ClassCastException</p>
<p>在java 1.5之后引入了泛型解决了上述问题，允许我们在创建集合的时候指定元素类型</p>
<p>当我们往集合中添加其它类型对象时，在编译时告知是否插入了类型错误的对象</p>
<p>再取出集合中对象时也不用再进行强制类型转换，使程序更加简洁</p>
</blockquote>
<ul>
<li><p>Java在1.5版本中引入了泛型</p>
<blockquote>
<p>在没有泛型之前，每次从集合中读取对象都必须进行类型转换</p>
<p>如果有人不小心插入了类型错误的对象，那么在运行时转换处理阶段就会出错</p>
<p>在提出泛型之后，我们可以告诉编译器集合中接受哪些对象类型</p>
<p>编译器会自动的为你的插入进行转化，并在编译时告知是否插入了类型错误的对象</p>
<p>这使程序变得更加安全更加清楚</p>
<p>泛型集合向上转型</p>
<blockquote>
<p>在Java标准库中的<code>ArrayList&lt;t&gt;</code>实现了<code>List&lt;t&gt;</code>接口，它可以向上转型为<code>List&lt;t&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;t&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;t&gt; &#123; ... &#125; </span><br><span class="line">List&lt;string&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;string&gt;();</span><br></pre></td></tr></table></figure>

<p>即类型<code>ArrayList&lt;t&gt;</code>可以向上转型为<code>List&lt;t&gt;</code></p>
<p>但是不能将类型<code>ArrayList&lt;t&gt;</code>可以向上转型为<code>ArrayList&lt;T&gt;</code>，T为t的父类</p>
</blockquote>
</blockquote>
</li>
<li><p>泛型擦除</p>
<blockquote>
<p><strong>当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉</strong></p>
<p>比如一个 List<String> 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）</p>
<p>上述规则即为泛型擦除，可以通过下面代码进一步理解泛型擦除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = ...; <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> list1; <span class="comment">// list2将元素当做Object处理</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展阅读</strong></p>
<p><strong>从逻辑上来看，List<String> 是List的子类，如果直接把一个List对象赋给一个List<String>对象应该引起编译错误，但实际上不会</strong></p>
<p><strong>对泛型而言，可以直接把一个List对象赋给一个 List<String> 对象，编译器仅仅提示“未经检查的转换”</strong></p>
<p>上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> ...; List&lt;String&gt; list2 = list1; <span class="comment">// 编译时警告“未经检查的转换”</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>泛型信息只存在于代码编译阶段，在进入 <code>JVM</code> 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除</strong></p>
<p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <code>&lt;T&gt;</code>则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends Number&gt;</code>则类型参数就被替换成类型上限</p>
<p>在泛型擦除后，<code>JVM</code>获取泛型信息则是通过<strong>泛型转译</strong>完成</p>
</blockquote>
</li>
</ul>
<h3 id="基本数据类型和引用类型"><a href="#基本数据类型和引用类型" class="headerlink" title="基本数据类型和引用类型"></a>基本数据类型和引用类型</h3><ul>
<li><p>基本数据类型共有八大类</p>
<blockquote>
<p>这八大数据类型又可分为四小类</p>
<p>分别是整数类型（byte&#x2F;short&#x2F;int&#x2F;long）、浮点类型（float、double）、字符类型（char）和布尔类型（boolean）</p>
<p>int是最常用的整数类型，double是最为常用的浮点类型，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换</p>
</blockquote>
</li>
<li><p>引用类型包括<strong>数组、类、接口</strong>类型，还有一种特殊的<strong>null类型</strong>，所谓引用数据类型就是对一个对象的引用，<strong>对象包括实例和数组两种</strong></p>
</li>
<li><p>不同数据类型占据的空间</p>
<blockquote>
<p>byte：1字节（8位），数据范围是 <code>-2^7 ~ 2^7-1</code></p>
<p>short：2字节（16位），数据范围是 <code>-2^15 ~ 2^15-1</code></p>
<p>int：4字节（32位），数据范围是 <code>-2^31 ~ 2^31-1</code></p>
<p>long：8字节（64位），数据范围是 <code>-2^63 ~ 2^63-1</code></p>
<p><strong>float：4字节（32位），数据范围大约是 <code>-3.4*10^38 ~ 3.4*10^38</code></strong></p>
<p>double：8字节（64位），数据范围大约是 <code>-1.8*10^308 ~ 1.8*10^308</code></p>
<p>char：2字节（16位），数据范围是 <code>\u0000 ~ \uffff</code></p>
<p>boolean：Java规范没有明确的规定，<strong>不同的JVM有不同的实现机制</strong></p>
</blockquote>
</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="自动拆箱和自动装箱-jdk-1-5"><a href="#自动拆箱和自动装箱-jdk-1-5" class="headerlink" title="自动拆箱和自动装箱(jdk 1.5)"></a>自动拆箱和自动装箱(jdk 1.5)</h4><ul>
<li><p>自动装箱是指把一个基本类型的数据直接赋值给对应的包装类型</p>
</li>
<li><p>自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型</p>
<blockquote>
<p>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程</p>
<p>比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法</p>
</blockquote>
</li>
<li><p>设计包装类的原因</p>
<blockquote>
<p>Java是一门非常纯粹的面向对象的编程语言，其设计理念是“一切皆对象”</p>
<p>但8种基本数据类型却不具备对象的特性</p>
<p>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯</p>
<p>这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约</p>
<p>所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以</p>
<p>如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了，有了包装类，这种问题就可以得以简化</p>
</blockquote>
</li>
<li><p>注意</p>
<blockquote>
<p>不同包装类不能直接进行比较：</p>
<p>不能用&#x3D;&#x3D;进行直接比较，因为它们是不同的数据类型</p>
<p>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等</p>
<p>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较</p>
<p>整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法</p>
<p>可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用&#x3D;&#x3D;进行比较</p>
</blockquote>
</li>
</ul>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul>
<li><p>常用类型：<code>String、StringBuffer、StringBuilder</code></p>
</li>
<li><p>String：不可变，字符串拼接会生成新的对象</p>
<blockquote>
<p> String是一个不可变类，也就是说，一个String对象创建之后，直到这个对象销毁为止，对象中的字符序列都不能被改变</p>
</blockquote>
</li>
<li><p><code>StringBuffer</code>：可变，可以对字符串进行各种操作，线程安全</p>
<blockquote>
<p><code>StringBuffer</code>对象则代表一个字符序列可变的字符串，当一个<code>StringBuffer</code>对象被创建之后，我们可以通过<code>StringBuffer</code>提供的append()、insert()、reverse()、<code>setCharAt()</code>、<code>setLength()</code>、等方法来改变这个字符串对象的字符序列</p>
<p>当通过<code>StringBuffer</code>得到期待中字符序列的字符串时，就可以通过<code>toString()</code>方法将其转换为String对象</p>
</blockquote>
</li>
<li><p><code>StringBuilder</code>：可变，可以对字符串进行各种操作，线程不安全</p>
<blockquote>
<p><code>StringBuilder</code>类是<code>JDK1.5</code>中新增的类，他也代表了字符串对象</p>
<p>和<code>StringBuffer</code>类相比，它们有共同的父类<code>AbstractStringBuilder</code>，二者无论是构造器还是方法都基本相同，不同的一点是，<code>StringBuilder</code>没有考虑线程安全问题，也正因如此，<code>StringBuilder</code>比<code>StringBuffer</code>性能略高</p>
</blockquote>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p>常用的方法</p>
<blockquote>
<p>char charAt(int index)：返回指定索引处的字符</p>
<p>String substring(int beginIndex， int endIndex)：从此字符串中截取出一部分子字符串</p>
<p>String[] split(String regex)：以指定的规则将此字符串分割成数组</p>
<p>String trim()：删除字符串前导和后置的空格</p>
<p>int indexOf(String str)：返回子串在此字符串首次出现的索引</p>
<p>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引</p>
<p>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头</p>
<p>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾</p>
<p>String toUpperCase()：将此字符串中所有的字符大写</p>
<p>String toLowerCase()：将此字符串中所有的字符小写</p>
<p>String replaceFirst(String regex， String replacement)：用指定字符串替换第一个匹配的子串</p>
<p>String replaceAll(String regex， String replacement)：用指定字符串替换所有的匹配的子串</p>
</blockquote>
</li>
<li><p>创建方式</p>
<blockquote>
<p>一是使用字符串直接量，另一种是使用new关键字</p>
<p>使用字符串直接量的方式来创建字符串时，JVM会使用常量池来管理这个字符串</p>
<p>使用new关键字来创建字符串时，JVM会<strong>先使用常量池来管理字符串直接量</strong>，再<strong>调用String类的构造器</strong>来创建一个新的String对象，新创建的String对象会被<strong>保存在堆内存中</strong></p>
<p>对比来说，采用new的方式会多创建出一个对象来，占用了更多的内存 ，所以建议采用直接量的方式来创建字符串</p>
</blockquote>
</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li><p>JVM是<strong>Java语言跨平台</strong>的关键，Java在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性</p>
<blockquote>
<p>运行程序的物理机千差万别，而JVM则在千差万别的物理机上面<strong>建立了统一的运行平台</strong>，实现了在任意一台JVM上编译的程序，都能在任何其他JVM上正常运行</p>
<p>这使得Java应用的开发比传统C&#x2F;C++应用的开发更高效快捷，程序员可以把精力放在具体业务逻辑，而不是放在保障物理硬件的兼容性上</p>
<p>只要了解了<strong>必要的Java类库</strong>、<strong>Java语法</strong>，学习<strong>适当的第三方开发框架</strong>，就已经基本满足日常开发的需要了，JVM会完成对<strong>硬件平台的兼容</strong>及对<strong>内存等资源的管理</strong>工作</p>
<p>HotSpot是Sun&#x2F;OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机</p>
<p>HotSpot既继承了Sun之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的<strong>热点代码探测技术</strong></p>
<p>HotSpot的热点代码探测能力可以<strong>通过执行计数器找出最具有编译价值的代码</strong>，然后通知<strong>即时编译器</strong>以方法为单位进行编译</p>
<p>如果一个方法被频繁调用，或方法中<strong>有效循环次数很多</strong>，将会分别触发标准即时编译和<strong>栈上替换编译</strong>行为</p>
<p>通过<strong>编译器与解释器</strong>恰当地<strong>协同工作</strong>，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更复杂的代码优化技术，输出质量更高的本地代码</p>
</blockquote>
</li>
</ul>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><ul>
<li><p><code>JVM</code>由三部分组成：类加载子系统、执行引擎、运行时数据区</p>
<blockquote>
<p><strong>类加载子系统</strong>，可以根据<strong>指定的全限定名</strong>来载入类或接口</p>
<p><strong>执行引擎</strong>，负责执行那些包含在<strong>被载入类的方法中的指令</strong></p>
<p>当程序运行时，<code>JVM</code>需要内存来存储许多内容，例如：字节码、对象、参数、返回值、局部变量、运算的中间结果等，<code>JVM</code>会把这些东西都存储到运行时数据区中，以便于管理</p>
<p><strong>运行时数据区</strong>又可以分为<strong>方法区</strong>、<strong>堆</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器</strong></p>
<p>运行时数据区是开发者重点要关注的部分，因为程序的运行与它密不可分，很多错误的排查也需要基于对运行时数据区的理解</p>
<p>在运行时数据区所包含的几块内存空间中，<strong>方法区和堆</strong>是线程之间<strong>共享</strong>的内存区域，而<strong>虚拟机栈、本地方法栈、程序计数器</strong>则是<strong>线程私有</strong>的区域，就是说每个线程都有自己的这个区域</p>
</blockquote>
</li>
<li><p>运行时数据区</p>
<blockquote>
<blockquote>
<p><strong>程序计数器</strong>可以看作是当<strong>前线程所执行的字节码的行号指示器</strong></p>
<p><strong>字节码解释器</strong>通过改变这个计数器的值来确定<strong>下一条需要执行的字节码指令</strong>，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令</p>
<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈</strong>也是线程私有的，它的<strong>生命周期与线程相同</strong></p>
<p>虚拟机栈描述的是<strong>Java方法执行的线程内存模型</strong>：</p>
<p>每个<strong>方法被执行</strong>的时候，Java虚拟机都会<strong>同步创建一个栈帧</strong>用于<strong>存储局部变量表、操作数栈、动态连接、方法出口</strong>等信息</p>
<p>每一个方法被<strong>调用直至执行完毕</strong>的过程，就对应着一个<strong>栈帧在虚拟机栈中从入栈到出栈</strong>的过程。</p>
<p>程序员最关注的、与对象内存分配关系最密切的区域是<strong>堆和栈</strong>两块</p>
<p>其中，<strong>栈通常就是指这里讲的虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<strong>局部变量表部分</strong></p>
<p>在Java虚拟机规范中，对这个内存区域规定了两类异常状况：</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</p>
<p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</p>
</blockquote>
<blockquote>
<p><strong>本地方法栈</strong>与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机<strong>执行Java方法服</strong>务，而本地方法栈则是为虚拟机使用到的<strong>本地方法服务</strong></p>
<p>Java虚拟机规范对本地方法栈中方法使用的<strong>语言、使用方式与数据结构</strong>并<strong>没有任何强制规定</strong>，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机直接就把本地方法栈和虚拟机栈合二为一</p>
<p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常</p>
</blockquote>
<blockquote>
<p><strong>堆</strong>是虚拟机所管理的内存中最大的一块</p>
<p>Java堆是被<strong>所有线程共享</strong>的一块内存区域，在<strong>虚拟机启动时创建</strong></p>
<p>此内存区域的<strong>唯一目的</strong>就是<strong>存放对象实例</strong>，Java世界里“几乎”所有的对象实例都在这里分配内存</p>
<p>堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”</p>
<p>堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是<strong>按照可扩展来实现的</strong></p>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，JVM将会抛出OutOfMemoryError异常</p>
</blockquote>
<blockquote>
<p><strong>方法区</strong>与堆一样，是各个线程共享的内存区域，它用于存储<strong>已被虚拟机加载的类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等数据</p>
<p>Java虚拟机规范中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”，目的是与堆区分开来</p>
<p><strong>运行时常量池</strong>是方法区的一部分</p>
<p><strong>Class文件</strong>中除了有<strong>类的版本、字段、方法、接口</strong>等描述信息外，还有一项信息是<strong>常量池表</strong>，用于存放<strong>编译期生成的各种字面量与符号引用</strong></p>
<p>根据Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul>
<li><p>内存溢出就是指程序运行过程中<strong>申请的内存大于系统能够提供的内存</strong>，导致无法申请到足够的内存，于是就发生了内存溢出</p>
</li>
<li><p>原因</p>
<blockquote>
<p>内存中<strong>加载的数据量过于庞大</strong>，如一次从数据库取出过多数据</p>
<p><strong>集合类中有对象的引用</strong>，<strong>使用完后未清空</strong>，使得JVM不能回收</p>
<p>代码中<strong>存在死循环</strong>或<strong>循环产生过多重复的对象实体</strong></p>
<p>使用的第三方软件中的BUG</p>
<p><strong>启动参数内存值设定的过小</strong></p>
</blockquote>
</li>
<li><p>解决方案（认为内存空间分配不足，直接增加内存 &#x3D;&gt; 检查日志是否抛出其他异常或错误 &#x3D;&gt; 对代码进行检查重点为集合类、循环等 &#x3D;&gt; 使用内存查看工具查看内存使用情况）</p>
<blockquote>
<p>第一步，<strong>修改JVM启动参数</strong>，直接增加内存</p>
<p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误</p>
<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置</p>
<p>第四步，使用内存查看工具动态查看内存使用情况</p>
</blockquote>
</li>
<li><p>内存溢出发生在哪些位置</p>
<blockquote>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能</p>
<blockquote>
<p><strong>Java堆溢出</strong></p>
<p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常</p>
</blockquote>
<blockquote>
<p><strong>虚拟机栈和本地方法栈溢出</strong></p>
<p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常</p>
</blockquote>
<blockquote>
<p><strong>方法区和运行时常量池溢出</strong></p>
<p>方法区溢出也是一种常见的内存溢出异常，在经常<strong>运行时生成大量动态类</strong>的应用场景里，就应该特别关注这些类的回收状况</p>
<p>这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用、基于OSGi的应用等</p>
<p>在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法区的一部分，所以上述问题在常量池中也同样会出现</p>
<p>而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免</p>
</blockquote>
<blockquote>
<p><strong>本地直接内存溢出</strong></p>
<p>直接内存的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值一致</p>
<p>如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul>
<li><p>内存泄漏，是指不再使用的对象仍然被引用，导致垃圾收集器无法回收它们的内存，由于不再使用的对象仍然无法清理，甚至这种情况可能会越积越多，最终导致致命的OutOfMemoryError</p>
</li>
<li><p>分析和解决的方法</p>
<blockquote>
<blockquote>
<p><strong>启用分析器</strong></p>
<p>Java分析器是通过应用程序监视和诊断内存泄漏的工具，它可以分析我们的应用程序内部发生的事情，例如如何分配内存</p>
<p>使用分析器，我们可以比较不同的方法并找到可以最佳利用资源的方式</p>
</blockquote>
<blockquote>
<p><strong>启用详细垃圾收集日志</strong></p>
<p>通过启用详细垃圾收集日志，我们可以跟踪GC的详细进度</p>
<p>要启用该功能，我们需要将以下内容添加到JVM的配置当中：<code>-verbose:gc</code></p>
<p>通过这个参数，我们可以看到GC内部发生的细节</p>
</blockquote>
<blockquote>
<p><strong>使用引用对象</strong>（强、弱、软、虚引用）</p>
<p>我们还可以借助java.lang.ref包内置的Java引用对象来规避问题，使用java.lang.ref包，而不是直接引用对象，即使用对象的特殊引用，使得它们可以轻松地被垃圾收集</p>
</blockquote>
<blockquote>
<p><strong>Eclipse内存泄漏警告</strong></p>
<p>对于JDK1.5以及更高的版本中，Eclipse会在遇到明显的内存泄漏情况时显示警告和错误</p>
<p>因此，在Eclipse中开发时，我们可以定期地访问“问题”选项卡，并更加警惕内存泄漏警告</p>
</blockquote>
<blockquote>
<p><strong>基准测试</strong></p>
<p>我们可以通过执行基准测试来衡量和分析Java代码的性能</p>
<p>通过这种方式，我们可以比较执行相同任务的替代方法的性能</p>
<p>这可以帮助我们选择更好的方法，并可以帮助我们节约内存</p>
</blockquote>
<blockquote>
<p><strong>代码审查</strong></p>
<p>最后，我们总是采用经典的老方式来进行简单的代码演练</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="垃圾回收方式"><a href="#垃圾回收方式" class="headerlink" title="垃圾回收方式"></a>垃圾回收方式</h4><ul>
<li><p>分类：新生代收集、老年代收集、混合收集、整堆收集</p>
<blockquote>
<p>新生代收集：目标为新生代的垃圾收集</p>
<p>老年代收集：目标为老年代的垃圾收集，目前只有<code>CMS</code>收集器会有这种行为</p>
<p>混合收集：目标为整个新生代及部分老年代的垃圾收集，目前只有<code>G1</code>收集器会有这种行为</p>
<p>整堆收集：目标为整个堆和方法区的垃圾收集</p>
<p><code>HotSpot</code>虚拟机内置了很多垃圾收集器，其中针对新生代的垃圾收集器有<code>Serial、ParNew、Parallel Scavenge</code>，针对老年代的垃圾收集器有<code>CMS、Serial Old、Parallel Old</code></p>
<p><code>HotSpot</code>还内置了面向整堆的<code>G1</code>收集器</p>
<p>在上述收集器中，常见的组合方式有： </p>
<blockquote>
<p><code>Serial + Serial Old</code>，是客户端模式下常用的收集器</p>
<p><code>ParNew + CMS</code>，是服务端模式下常用的收集器</p>
<p><code>Parallel Scavenge + Parallel Old</code>，适用于后台运算而不需要太多交互的分析任务</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li><p>标记-清除、标记-整理、标记-复制</p>
<blockquote>
<p>标记-清除算法</p>
<blockquote>
<p> 算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象</p>
<p> 它主要有如下两个缺点：</p>
<p> 第一个是<strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低</p>
<p> 第二个是<strong>内存空间碎片化</strong>问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当程序在运行过程中需要分配较大对象时无法找到足够的连续的内存而不得不提前触发另一次垃圾收集</p>
</blockquote>
<p>标记-整理算法</p>
<blockquote>
<p>针对老年代对象的存亡特征，1974年<code>Edward Lueders</code>提出了另外一种有针对性的“标记-整理”算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让<strong>所有存活的对象都向内存空间一端移动</strong>，然后直接清理掉边界以外的内存</p>
<p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”</p>
</blockquote>
<p>标记-复制算法</p>
<blockquote>
<p>将可用<strong>内存按容量划分为大小相等的两块</strong>，每次只使用其中的一块</p>
<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</p>
<p>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可</p>
<p>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点</p>
<p>另外，如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销</p>
<p>所以，现在的商用Java虚拟机大多都优先采用了这种收集算法去回收<strong>新生代</strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="*类加载"></a>*类加载</h3><ul>
<li><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>七个阶段，其中<strong>验证、准备、解析</strong>三个部分统称为<strong>连接</strong>，而前五个阶段则是<strong>类加载</strong>的完整过程</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220226/4107856_1645862388602/D7FE993370822EC9232F21F54879124E" alt="img"></p>
</li>
<li><p>加载过程</p>
<blockquote>
<p>在加载阶段<code>JVM</code>需要在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</p>
<p>验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong></p>
<p><strong>准备阶段</strong>是正式为类中<strong>定义变量（静态变量）分配到内存并设置类变量初始值</strong>的阶段，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域</p>
<p><strong>解析阶段</strong>是Java虚拟机将常量池内的<strong>符号替换为直接引用</strong>的过程，符号引用以一组符号来描述所引用的目标，直接引用是可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄</p>
<p>类的初始化阶段是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序</p>
<p>本质上，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>的过程<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物</p>
</blockquote>
</li>
<li><p>类必须”初始化”的几种情况</p>
<blockquote>
<p>使用new实例化对象、读写类的静态字段、调用类的静态方法时</p>
<p>使用java.lang.reflect包的方法对类型进行<strong>反射调用</strong>时</p>
<p>当初始化类时，若发现其父类还没有进行过初始化，则先初始化这个父类</p>
<p><strong>虚拟机启动时，需要指定一个要执行的主类，虚拟机会先初始化这个主类</strong></p>
<p>当使用<code>JDK 7</code>新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、<code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</p>
<p>当一个接口中定义了<code>JDK 8</code>新加入的<strong>默认方法</strong>（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
</blockquote>
</li>
</ul>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul>
<li><p>Serial收集器是最基础、历史最悠久的收集器(标记-复制)(新生代)</p>
<blockquote>
<p>这个收集器是一个<strong>单线程工作</strong>的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>，直到它收集结束</p>
</blockquote>
</li>
<li><p>ParNew收集器实质上是Serial收集器的多线程并行版本(标记-复制)(新生代)</p>
<blockquote>
<p>除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致</p>
</blockquote>
</li>
<li><p>Parallel Scavenge收集器也是一款并行收集的多线程收集器(标记-复制)(新生代)</p>
<blockquote>
<p>它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量</strong></p>
</blockquote>
</li>
<li><p>Serial Old是Serial收集器的老年代版本，它同样是一个<strong>单线程收集器</strong>，使用<strong>标记-整理</strong>算法，这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p>
</li>
<li><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持<strong>多线程并发收集</strong>，基于<strong>标记-整理</strong>算法实现</p>
<blockquote>
<p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在<strong>注重吞吐量或者处理器资源较为稀缺</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</p>
</blockquote>
</li>
<li><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，从名字上就可以看出CMS收集器是基于<strong>标记-清除</strong>算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：<strong>初始标记、并发标记、重新标记、并发清除</strong></p>
</li>
<li><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式到了JDK 8 Update 40的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”。</p>
</li>
<li><p>搭配</p>
<blockquote>
<p>Serial收集器搭配Serial Old使用</p>
<p>ParNew收集器搭配CMS使用</p>
<p>Parallel Scavenge收集器搭配Parallel Old使用</p>
<p>G1是整堆收集器，它无需搭配其他的垃圾收集器</p>
</blockquote>
</li>
</ul>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul>
<li><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器</p>
<blockquote>
<p>CMS收集器是基于<strong>标记清除</strong>算法实现的</p>
<p>整个清理过程分为四个步骤，包括：<strong>初始标记、并发标记、重新标记、并发清除</strong>，其中初始标记、重新标记这两个步骤仍然需要“Stop The World”</p>
<blockquote>
<p>初始标记仅仅只是标记一下<strong>GC Roots能直接关联到的对</strong>象，速度很快。</p>
<p>并发标记阶段就是<strong>从GC Roots的直接关联对象</strong>开始<strong>遍历整个对象图</strong>的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</p>
<p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致<strong>标记产生变动的那一部分对象</strong>的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</p>
<p>并发清除阶段，清理删除掉<strong>标记阶段判断的已经死亡的对象</strong>，由于<strong>不需要移动存活对象</strong>，所以这个阶段也是可以与用户线程同时并发的</p>
</blockquote>
</blockquote>
</li>
<li><p>CMS是一款优秀的收集器</p>
<blockquote>
<p>它最主要的优点：<strong>并发收集、低停顿</strong></p>
<p>CMS收集器是HotSpot虚拟机追求低停顿的第一次成功尝试，有以下三个明显的缺点：</p>
<p>并发阶段，它虽然不会导致用户线程停顿，却因为占用一部分线程而<strong>导致应用程序变慢</strong>，<strong>降低总吞吐量</strong></p>
<p>它<strong>无法处理“浮动垃圾”</strong>，<strong>有可能会出现“并发失败”</strong>进而导致另一次Full GC的发生</p>
<p>它是一款基于标记清除算法实现的收集器，这意味着收集结束时<strong>会有大量空间碎片</strong>产生</p>
</blockquote>
</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><ul>
<li><p>Garbage First（G1）收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式</p>
<blockquote>
<p>在G1收集器出现之前的所有其他收集器，垃圾收集的目标范围要么是整个新生代，要么就是整个老年代，再要么就是整个Java堆</p>
<p>G1跳出了这个限制，它可以面向堆内存任何部分来组成回收集进行回收，衡量标准是哪块内存中存放的垃圾数量最多，回收收益最大，这就是Mixed GC模式</p>
<p>G1也仍是遵循<strong>分代收集理论</strong>设计的，但其堆内存的布局与其他收集器有非常明显的差异：</p>
<p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，还有一类专门用来存储大对象的特殊区域（Humongous Region）</p>
<p>G1认为只要超过了Region一半的对象即可判定为大对象，而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p>
<p>更具体的处理思路是，让<strong>G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值</strong>，然后在<strong>后台维护一个优先级列表</strong>，每次根据<strong>用户设定允许的收集停顿时间</strong>，优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来</p>
<p>G1收集器的运作过程大致可划分为以下四个步骤：<strong>初始标记、并发标记、最终标记、筛选回收</strong></p>
<p>其中，<strong>初始标记和最终标记</strong>阶段仍然需要<strong>停顿所有的线程</strong>，但是耗时很短</p>
</blockquote>
</li>
<li><p>G1与CMS的对比</p>
<blockquote>
<p>G1从<strong>整体</strong>来看是基于<strong>标记整理</strong>算法实现的收集器，但从<strong>局部</strong>上看又是基于<strong>标记复制</strong>算法实现</p>
<p>这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存</p>
<p>比起CMS，G1的弱项也可以列举出不少</p>
<p>例如在用户程序运行过程中，G1无论是为了<strong>垃圾收集产生的内存占用</strong>还是程序运行时的<strong>额外执行负载</strong>都要比CMS要高</p>
<p>G1与CMS的选择： (<strong>小内存用CMS、大内存用G1</strong>)</p>
<p>目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在<strong>大内存应用</strong>上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在<strong>6GB至8GB</strong>之间</p>
</blockquote>
</li>
</ul>
<h4 id="GC的可达性分析"><a href="#GC的可达性分析" class="headerlink" title="GC的可达性分析"></a>GC的可达性分析</h4><ul>
<li><p>当前主流的商用程序语言的内存管理子系统，都是通过<strong>可达性分析</strong>算法来判定对象是否存活的</p>
<blockquote>
<p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的</p>
</blockquote>
</li>
<li><p>Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<blockquote>
<p>在<strong>虚拟机栈中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p>
<p>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量</p>
<p>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池里的引用</p>
<p>在<strong>本地方法栈中引用的对象</strong></p>
<p><strong>JVM内部的引用</strong>，如基本数据类型对应的<strong>Class对象</strong>，<strong>常驻的异常对象</strong>，以及<strong>系统类加载器</strong></p>
<p>所有<strong>被同步锁持有的对象</strong></p>
<p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p>
</blockquote>
</li>
<li><p>真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<blockquote>
<p>第一次标记</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象<strong>是否有必要执行finalize()方法</strong></p>
<p>假如对象<strong>没有覆盖finalize()方法</strong>，或者<strong>finalize()方法已经被虚拟机调用过</strong>，那么虚拟机将这两种情况都视为“没有必要执行”</p>
<p>反之，该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法</p>
<p>第二次标记</p>
<p>稍后，收集器将对F-Queue中的对象进行第二次小规模的标记</p>
<p>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合</p>
<p>如果对象这时候还没有逃脱，那基本上它就真的要被回收了</p>
<p>finalize()方法是对象逃脱死亡命运的最后一次机会，需要注意的是，任何一个对象的<strong>finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行</p>
<p>finalize()方法的<strong>运行代价高昂，不确定性大，无法保证各个对象的调用顺序</strong>，如今已被官方明确声明为不推荐使用的语法</p>
</blockquote>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>引导类加载器</li>
</ul>
<blockquote>
<p>这个类加载器负责加载存放在<code>&lt;java_home&gt;\lib</code>目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中</p>
<p>注意，Java虚拟机会按照文件名识别类库，例如rt.jar、tools.jar，对于名字不符合的类库即使放在lib目录中也不会被加载</p>
<p><strong>启动类加载器无法被Java程序直接引用</strong>，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可，即让java.lang.ClassLoader.getClassLoader()返回null</p>
</blockquote>
<ul>
<li><p>扩展类加载器</p>
<blockquote>
<p>这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的</p>
<p>它负责加载<code>&lt;java_home&gt;\lib\ext</code>目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库</p>
<p>由于扩展类加载器是由Java代码实现的，开发者<strong>可以直接在程序中使用扩展类加载器来加载Class文件</strong></p>
</blockquote>
</li>
<li><p>应用程序类加载器</p>
<blockquote>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现</p>
<p>它负责<strong>加载用户类路径（ClassPath）上所有的类库</strong>，开发者同样可以直接在代码中使用这个类加载器</p>
</blockquote>
</li>
<li><p>双亲委派模型</p>
<blockquote>
<p>双亲委派模型要求<strong>除了顶层的启动类加载器</strong>外，<strong>其余的类加载器都应有自己的父类加载器</strong></p>
<p>不过这里类加载器之间的父子关系一般<strong>不是以继承的关系来实现</strong>的，而是通常使用<strong>组合关系</strong>来复用父加载器的代码</p>
<p>双亲委派模型的工作过程：</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父<strong>加载器反馈自己无法完成这个加载请求</strong>时，<strong>子加载器才会尝试自己去完成加载</strong></p>
<p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是<strong>Java中的类</strong>随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong></p>
<p>例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类</p>
<p>反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱</p>
</blockquote>
</li>
<li><p>双亲委派模型的破坏</p>
<blockquote>
<p>双亲委派模型的第一次“被破坏”发生在双亲委派模型出现之前</p>
<p>双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类ClassLoader则在Java的第一个版本中就已经存在，面对<strong>已经存在的用户自定义类加载器的代码</strong>，Java设计者们引入双亲委派模型时不得不做出一些妥协</p>
<p>为了兼容这些已有代码，只能在之后的ClassLoader中添加一个protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码</p>
<p>双亲委派的具体逻辑就实现在这里面，按照loadClass()的逻辑，如果父类加载失败，会自动调用自己的findClass()来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器符合双亲委派规则</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的 双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？一个典型的例子便是<strong>JNDI服务</strong>，JNDI现在已经是Java的标准服务，<strong>它的代码由启动类加载器来完成加载</strong>，肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它<strong>需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口的代码</strong>，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个<strong>类加载器可以通过Thread类的setContextClassLoader()方法进行设置</strong>，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都<strong>没有设置过的话</strong>，那这个类加载器<strong>默认就是应用程序类加载器</strong>。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。<strong>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码</strong>，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情</p>
<blockquote>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的 这里所说的“动态性”指的是一些非常“热”门的名词：<strong>代码热替换、模块热部署</strong>等</p>
<p><strong>OSGi实现模块化热部署</strong>的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换</p>
<p>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p>
</blockquote>
</blockquote>
</li>
<li><p>注意：如果不同的类加载器，加载同一个类，加载出来的俩个类不属于同一个类</p>
</li>
</ul>
<h4 id="类实例化的过程"><a href="#类实例化的过程" class="headerlink" title="类实例化的过程"></a>类实例化的过程</h4><ul>
<li><p>在JVM中，对象的创建遵循如下过程：</p>
<blockquote>
<p>JVM遇到一条字节码new指令时</p>
<p>首先将去<strong>检查这个指令的参数</strong>是否能在常量池中定位到一个<strong>类的符号引用</strong>，并且检查这个<strong>符号引用代表的类是否已被加载、解析和初始化过</strong></p>
<p>如果没有，那必须先<strong>执行相应的类加载过程</strong></p>
<p>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong></p>
<p>对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来</p>
<p>内存分配完成之后，虚拟机必须<strong>将分配到的内存空间都初始化为零值</strong>，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行(<strong>使用TLAB是利用线程私有的区域为对象分配空间可以避免出现多线程冲突)</strong>(<strong>TLAB处在eden区</strong>)</p>
<p>这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值</p>
<p>接下来，虚拟机还要<strong>对对象进行必要的设置</strong>，例如这个<strong>对象是哪个类的实例</strong>、如何才能找到类的元数据信息、<strong>对象的哈希码</strong>、<strong>对象的GC分代年龄</strong>等信息，这些信息存放在对象的<strong>对象头</strong>之中</p>
<p><strong>根据虚拟机当前运行状态</strong>的不同，如是否启用偏向锁等，<strong>对象头会有不同的设置方式</strong></p>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了</p>
<p>但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<code>&lt;init&gt;()</code>方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</p>
<p>一般来说，new指令之后会接着执行<code>&lt;init&gt;()</code>方法，按照程序员的意愿对<strong>对象进行初始化</strong>，这样一个真正可用的对象才算完全被构造出来</p>
</blockquote>
<blockquote>
<p><strong>检查常量池中是否有该对象符号引用，并判断该类是否已被加载、解析、初始化过</strong></p>
<p><strong>否则先进行类加载</strong></p>
<p><strong>为对象分配内存空间，并将空间置零</strong></p>
<p><strong>对对象进行必要设置，属于哪个类、如何找到类的元数据信息、哈希码、分代年龄，将这些信息写入对象头，虚拟机根据当前状态，对象头有不同的设置方式，是否启用锁等等</strong></p>
<p><strong>执行类中编写的初始化代码</strong></p>
</blockquote>
</li>
</ul>
<h4 id="Java四种引用方式"><a href="#Java四种引用方式" class="headerlink" title="Java四种引用方式"></a>Java四种引用方式</h4><ul>
<li><p>JDK 1.2版之前，一个对象只有“被引用”或者“未被引用”两种状态</p>
<blockquote>
<p>对于描述一些“不太重要”的对象就显得无能为力</p>
<p>我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象</p>
<p>很多系统的缓存功能都符合这样的应用场景</p>
</blockquote>
</li>
<li><p>JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱</p>
<blockquote>
<blockquote>
<p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系</p>
<p>无论任何情况下，只要强引用关系还存在，<strong>垃圾收集器就永远不会回收掉被引用的对象</strong></p>
</blockquote>
<blockquote>
<p>软引用是用来描述一些还有用，但非必须的对象</p>
<p>只被软引用关联着的对象，在系统将要发生<strong>内存溢出异常前</strong>，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</p>
</blockquote>
<blockquote>
<p>弱引用也是用来描述那些非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生</strong>为止</p>
<p>当垃圾收集器开始工作，<strong>无论当前内存是否足够</strong>，都会回收掉只被弱引用关联的对象</p>
</blockquote>
<blockquote>
<p>虚引用是最弱的一种引用关系</p>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的<strong>唯一目的</strong>只是为了能在这个<strong>对象被收集器回收时收到一个系统通知</strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul>
<li><p>相同点</p>
<blockquote>
<p>接口和抽象类都<strong>不能被实例化</strong>，它们都<strong>位于继承树的顶端</strong>，用于被其它类实现和继承</p>
<p>接口和抽象类都可以有抽象方法，实现接口或继承抽象类的普通子类都<strong>必须实现这些抽象方法</strong></p>
</blockquote>
</li>
<li><p>区别（普通方法、普通成员变量、构造器、初始化块）</p>
<blockquote>
<p>接口里只能包含抽象方法、**静态方法(必须实现)**和默认方法，不能为普通方法提供方法实现</p>
<p>抽象类则可以包含<strong>普通方法</strong></p>
<p>接口里只能定义静态常量，不能定义普通成员变量</p>
<p>抽象类里既可以定义<strong>普通成员变量</strong>，也可以定义静态常量</p>
<p>接口里不包含构造器</p>
<p>抽象类可以包含<strong>构造器</strong>，但抽象类的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的<strong>初始化操作</strong></p>
<p>接口里不能包含初始化块，抽象类则可以<strong>包含初始化块</strong></p>
<p>一个类最多只能有一个父类，包括抽象类</p>
<p>但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足</p>
<p>总之，接口通常是定义允许多个实现的类型的最佳途径，但当演变的容易性比灵活性和功能更加重要时，应该使用抽象类来定义类型</p>
</blockquote>
</li>
<li><p>总结</p>
<blockquote>
<p>在二者的设计目的上</p>
<blockquote>
<p>接口作为系统与外界交互的窗口，体现了一种<strong>规范</strong></p>
<p>对于接口的实现者来说，接口规定了<strong>实现者必须向外提供哪些服务</strong></p>
<p>对于接口的调用者而言，接口规定了<strong>调用者可以调用哪些服务，以及如何调用这些服务</strong></p>
<p>当在一个程序中使用接口时，接口是多个模块间的耦合标准</p>
<p>当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准</p>
</blockquote>
<blockquote>
<p>抽象类则不一样，抽象类作为系统中多个子类的共同父类，它体现的是一种<strong>模板式设计</strong></p>
<p>抽象类作为多个子类的父类，它可以被当作系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当作最终产品，必须要有更进一步的完善</p>
<p>这种完善可能有几种不同方式</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals()"></a>&#x3D;&#x3D;和equals()</h3><ul>
<li><p>&#x3D;&#x3D;和equals()都是JAVA中判断两个变量是否相等的方式</p>
<blockquote>
<p>如果判断的是两个基本类型的变量，并且两者都是数值类型(<strong>不一定要求数据类型完全相同</strong>)，只要两个变量的值相等就会返回TRUE</p>
<p>对于两个引用变量只有他们指向同一个引用时，&#x3D;&#x3D;才会返回TRUE</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子类对象指向父类引用</span><br><span class="line"><span class="type">test01</span> <span class="variable">test01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test01</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> test01;</span><br><span class="line">System.out.println(o == test01);</span><br><span class="line">System.out.println(o.equals(test01));</span><br><span class="line">返回结果均为<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;不能用于比较类型上没有父子关系的两个对象，会报错</p>
<p>equals()方法是Object类提供的一个实例方法，所以所有的引用变量都能调用equals()方法来判断他是否与其他引用变量相等，但使用这个方法来判断两个引用对象是否相等的判断标准与使用&#x3D;&#x3D;运算符没有区别，它同样要求两个引用变量指向同一个对象才会返回true，但如果这样的话equals()方法就没有了存在的意义，所以如果我们希望自定义判断相等的标准时，可以通过重写equals()方法来实现</p>
<p>重写equals()方法时，相等条件是由业务要求决定的，因此equals()方法的实现是由业务要求决定的</p>
</blockquote>
</li>
</ul>
<h3 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h3><ul>
<li><p>hashCode()方法的主要用途是获取哈希码，equals()主要用来比较两个对象是否相等</p>
</li>
<li><p>俩个方法之间有个约定：</p>
<blockquote>
<p>如果两个对象相等，它们必须有相同的哈希码</p>
<p>但如果两个对象的哈希码相同，他们却不一定相等</p>
<p>因此根据业务重写equals()方法时，为了使该约定仍然成立，所以也需要重写hashCode()</p>
</blockquote>
</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li><p>访问修饰符有：public、protected、默认、private</p>
<blockquote>
<blockquote>
<p>我的理解</p>
<p>public修饰时，所有类都可以访问</p>
<p>protected修饰时，同一包下或者子类可以访问</p>
<p>默认修饰符修饰时，只有同一包下的类才可以访问</p>
<p>private修饰时，只有在当前类内部才能访问</p>
</blockquote>
<blockquote>
<p>private：类中被private修饰的成员只能在当前类的内部被访问，使用它来修饰成员变量，从而将成员变量隐藏在这个类的内部</p>
<p>default：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰，那么他就是default级别的，default访问控制的类成员或者外部类可以被相同包下的其他类访问</p>
<p>protected：如果一个类成员被protected访问修饰符修饰，那么这个成员不但可以被同一个包下的其他类访问，还可以被其他包下的子类访问，一般来讲，如果一个方法被protected修饰，那么通常是希望它的子类来重写它</p>
<p>public：这是Java中最宽松的访问级别，如果类成员被这个修饰符修饰，那么无论访问类和被访问类在不在一个包下，有没有父子关系，这个类成员都可以被访问到</p>
</blockquote>
</blockquote>
</li>
<li><p>扩展：</p>
<blockquote>
<p>对于<strong>局部变量</strong>，它的作用域就是他所在的方法，不可能被其它类所访问，所以不能使用访问修饰符来修饰</p>
<p>对于<strong>外部类</strong>，它只有两种控制级别：</p>
<p>public和默认，外部类之所以不能用protected和private修饰，是因为外部类<strong>没有处于任何类的内部</strong>，所以就<strong>没有它所在类的内部，所在类的子类两个范围</strong>，protected和private没有意义</p>
<p>使用public声明的外部类可以被所有类引用</p>
<p>不使用访问修饰符创建的外部类只有同一个包内的类能引用</p>
</blockquote>
</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li><p>static可以用来修饰方法、变量、代码块、内部类</p>
</li>
<li><p>修饰类中方法、变量、代码块</p>
<blockquote>
<p>被修饰的方法、变量、代码块被称为类方法、类成员变量、静态代码块</p>
<p>static与final共同修饰的称为常量</p>
<p>类方法、类成员变量、常量都可以通过类名直接调用</p>
<blockquote>
<p>类成员变量为这个类所拥有，该类的所有对象都可以对其进行访问或修改，在类加载的时候就进行初始化</p>
</blockquote>
<blockquote>
<p>类方法内部只能调用类方法或者类成员变量，不能调用该类的普通成员，并且不能被子类重写</p>
</blockquote>
<blockquote>
<p>静态代码块作用于类加载的时候，对该类的类成员变量进行初始化等操作</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>static关键字有一条非常重要的规则，即类成员不能访问实例成员，因为类成员属于类的，类成员的作用域比实例成员的作用域更大，很容易出现类成员初始化完成时，但实例成员还没被初始化，这时如果类成员访问实力成员就会引起大量错误</p>
<p>static修饰的部分会和类同时被加载</p>
<p>被static修饰的成员先于对象存在，因此，当一个类加载完毕，即使没有创建对象也可以去访问被static修饰的部分</p>
<p>静态方法中没有this关键词，因为静态方法是和类同时被加载的，而this是随着对象的创建存在的</p>
<p>静态比对象优先存在，静态可以访问静态，但静态不能访问非静态而非静态可以访问静态</p>
</blockquote>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li><p>final可以修饰类、方法、变量</p>
<blockquote>
<p>final关键字可以用来标志其修饰的类，方法和变量不可变</p>
<p>修饰类表示该类不可被继承</p>
<p>修饰方法则该方法不能被子类重写</p>
<p>修饰变量时，当变量为基本数据类型时，初始化之后不可以在进行修改和赋值，当为引用变量时，赋初值之后，指向的地址不可改变，当该变量为局部变量时，必须初始化之后才能使用</p>
<blockquote>
<p>修饰变量时，代表该变量不可被改变，一旦获得了初始值，该final变量的值就不能被重新赋值</p>
<p>final既可以修饰成员变量（包括类变量和实例变量），也可以修饰局部变量、形参</p>
<p>对于final修饰的成员变量而言，一旦有了初始值就不能被重新赋值</p>
<p>Java语法规定：<strong>final修饰的成员变量必须由程序员显示的指定初始值</strong></p>
<p>final修饰的实例变量，要么在定义该实例变量时指定初始值，要么在普通初始化块或构造器中为该实例变量指定初始值</p>
<p>但要注意的是，如果普通初始化块已经为某个实例变量指定了初始值，则不能再在构造器中为该实例变量指定初始值</p>
<p>final修饰的<strong>类变量</strong>，要么在<strong>定义该变量时指定初始值</strong>，要么在<strong>静态初始化块</strong>中为该类变量指定初始值</p>
<p>实例变量不能在静态初始化块中指定初始值，因为静态初始化块是静态成员，不可以访问实例变量</p>
<p><strong>类变量不能在普通初始化块中指定初始值</strong>，因为类变量在类初始化阶段已经被初始化了，普通的初始化块不能为其重新赋值</p>
<p><strong>系统不会为局部变量进行初始化</strong>，所以局部变量<strong>必须由程序员显示的初始化</strong></p>
<p>使用final修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值</p>
<p>如果final修饰的局部变量在定义是没有指定默认值，则可以在后面的代码中对该final变量赋初始值，但只能一次，不能重复赋值</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>三大基本特征：封装，继承，多态</p>
</li>
<li><p>封装</p>
<blockquote>
<p>封装是指将<strong>对象的状态信息隐藏在对象内部</strong>，不允许外部直接访问对象内部信息，只能通过事先预定的方法访问数据</p>
<p>优点：</p>
<blockquote>
<p>隐藏类的成员变量和实现细节，不允许外部直接访问</p>
<p>规范使用者的行为，让使用者只能通过事先预定的方法访问数据，通过在这个方法中加入逻辑控制，限制使用者对成员变量的不合理访问</p>
<p>可<strong>进行数据检查</strong>，从而有利于保证对象信息的完整性</p>
<p>便于修改，提高<strong>代码的可维护性</strong></p>
</blockquote>
</blockquote>
</li>
<li><p>继承</p>
<blockquote>
<p>继承是面向对象<strong>实现代码复用</strong>的重要手段，Java通过extends作为关键字实现类的继承，实现继承的类被称为子类，被继承的类称为父类（有的也被称为基类和超类）</p>
<p>父类和子类的关系是一种一般和特殊的关系，父类更加一般，子类在父类的基础上拥有更多特殊性</p>
<p>优点：</p>
<blockquote>
<p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性，提高了代码复用</p>
<p>提高代码的可扩展性，很多开源框架的扩展接口都是通过继承父类来完成的</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p><strong>继承是侵入性的</strong>，只要继承，就必须拥有父类的所有属性和方法</p>
<p><strong>降低代码的灵活性</strong>，子类必须拥有父类的属性和方法</p>
<p>增强了<strong>耦合性</strong>，当父类被修改时，需要考虑子类的修改，这种修改可能会导致大段的代码需要重构</p>
</blockquote>
</blockquote>
</li>
<li><p>多态</p>
<blockquote>
<p>多态的实现离不开继承</p>
<p>设计程序时，将参数定义为父类型，调用程序时，根据实际情况，传入某个子类型的实例，这就实现了多态</p>
<p>对于父类型，可以有三种形式，即<strong>普通的类、抽象类、接口</strong></p>
<p>对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法</p>
<p>优点：提高了代码的维护性，提高了代码的扩展性</p>
<p>实现多态的三个条件：</p>
<blockquote>
<p>需要有<strong>继承关系的存在</strong></p>
<p>需要有<strong>方法的重写</strong></p>
<p>需要有<strong>父类的引用指向子类对象</strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h5><ul>
<li><p>重载：在一个类中，有多个方法名相同，形参列表不同（形参个数，形参类型、顺序不同的）的方法</p>
<blockquote>
<p>重载要求发生在同一个类中，多个方法之间方法名相同且参数列表不同</p>
<p>注意重载与方法的返回值以及访问修饰符无关</p>
</blockquote>
</li>
<li><p>重写：子类有和父类同名且形参列表一致的非静态非私有方法，且子类方法访问修饰符大于等于父类中的方法</p>
<blockquote>
<p>重写发生在父类子类中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同</p>
<p><strong>返回值要小于等于父类方法</strong>，<strong>抛出的异常要小于等于父类方法</strong>，<strong>访问修饰符则要大于等于父类方法</strong></p>
<p>若父类方法的访问修饰符为private，则子类不能对其重写</p>
<p>static修饰的方法也不能重写，只能算是子类的同名方法</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>构造器可以重载但不能重写</p>
<p>同一个类中有多个构造器，多个构造器的形参列表不同就被称为构造器重载，构造器重载让Java类包含了多个初始化逻辑，从而允许使用不同的构造器来初始化对象</p>
<p>构造方法不能重写，因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名</p>
<p>如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的</p>
<p>父类方法和子类方法之间也有<strong>可能发生重载</strong>，因为子类会获得父类的方法，如果子类中定义了一个与父类方法名字相同但参数列表不同的方法，就会形成子类方法和父类方法的重载</p>
</blockquote>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote>
<p>Throwable是异常的顶层父类，代表所有的非正常情况</p>
<p>它有两个直接子类，分别是Error、Exception</p>
<p>Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断</p>
<p>通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类</p>
<p>Exception是异常，它被分为两大类，分别是Checked异常和Runtime异常</p>
<p>所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常</p>
<p>Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译</p>
<p>Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现</p>
</blockquote>
<h4 id="error和exception"><a href="#error和exception" class="headerlink" title="error和exception"></a>error和exception</h4><ul>
<li><p>Error 和 Exception 都是Throwable的子类</p>
<blockquote>
<p>在java中只有Throwable类型的实例才可以被抛出或者捕获，它是异常处理机制的基本类型</p>
<p>Exception 和 Error体现了java平台设计者对不同异常情况的分类， <strong>Exception是程序正常运行中</strong>，<strong>可以预料的意外情况</strong>，可以被捕获，进行相应的处理</p>
<p><strong>Error 是指正常情况下，不大可能出现的情况</strong>，绝大部分的Error 都会导致程序处于非正常的，不可恢复的状态， 不需要捕获， 常见的OutOfMemoryError 是Error的子类</p>
<p>Exception 分为<strong>可检查异常(checked)</strong> 和 <strong>不可检查异常(unchecked)</strong></p>
<blockquote>
<p>常见的编译异常有：</p>
<p>OException：输入输出流异常</p>
<p>FileNotFoundException：文件找不到的异常</p>
<p>ClassNotFoundException：类找不到的异常</p>
<p>DataFormatException：数据格式化异常</p>
<p>NoSuchFieldException：没有匹配的属性异常</p>
<p>NoSuchMethodException：没有匹配的方法异常</p>
<p>SQLException：数据库操作异常</p>
<p>TimeoutException：执行超时异常</p>
<p>常见的运行时异常：</p>
<p>RuntimeException：运行时异常</p>
<p>NullPointerException:空指针异常</p>
<p>ArrayIndexOutofBoundsException：数组越界异</p>
<p>ClassCastException：类型转换异常</p>
<p>IllegalArgumentException：非法的参数异常</p>
<p>InputMismatchException：输入不匹配</p>
</blockquote>
<p>可检查异常在源代码里<strong>必须显式的进行捕获处理</strong>，这是编译期检查的一部分，不可检查异常是指运行时异常， 比如NullPointerException， ArrayIndexOutOfBoundsException之类， 通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求</p>
</blockquote>
</li>
</ul>
<h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul>
<li><p>异常处理机制可以<strong>让程序具有极好的容错性和健壮性</strong>，当程序运行出现了意料之外的状况时，系统会生成一个Exception对象来通知程序，从而实现“业务功能实现部分代码”与“错误处理部分代码”分离，使程序获得更好的可读性</p>
</li>
<li><p>Java的异常机制可以分成<strong>异常处理</strong>、<strong>抛出异常</strong>和<strong>异常跟踪栈</strong>问题三个部分</p>
<blockquote>
<blockquote>
<p><strong>处理异常</strong>的语句由try、catch、finally三部分组成</p>
<p>try块用于<strong>包裹业务代码</strong>，catch块用于<strong>捕获并处理某个类型的异常</strong>，finally块则用于<strong>回收资源</strong></p>
<p>如果业务代码发生异常，系统就会创建一个异常对象，并将这个异常对象提交给JVM，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理</p>
<p>如果JVM没有找到可以处理异常的catch代码块，那么<strong>运行环境会终止</strong>，<strong>Java程序也会退出</strong></p>
<p>若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行（一般情况下）</p>
</blockquote>
<blockquote>
<p>当程序出现错误时，系统会自动<strong>抛出异常</strong>，Java也允许程序主动抛出异常</p>
<p>当业务代码中，判断某项错误的条件成立时，可以使用<strong>throw</strong>关键字向外抛出异常</p>
<p>如果当前方法不知道该如何处理这个异常，可以在方法签名上通过<strong>throws关键字声明抛出异常</strong>，则该异常将交给JVM处理</p>
</blockquote>
<blockquote>
<p>程序运行时，经常会发生一系列方法调用，从而形成<strong>方法调用栈</strong></p>
<p>异常机制会导致异常在这些方法之间传播，而<strong>异常传播的顺序与方法的调用相反</strong></p>
<p>异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推</p>
<p>最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印<strong>异常跟踪栈</strong>的信息</p>
</blockquote>
</blockquote>
</li>
<li><p>throw与throws的区别：</p>
<blockquote>
<blockquote>
<p>throws：</p>
<p>只能在方法签名中使用</p>
<p>可以声明抛出多个异常，多个异常之间用逗号隔开</p>
<p>表示<strong>当前方法不知道如何处理这个异常</strong>，这个异常由该方法的调用者处理（如果main方法也不知该怎么处理异常，这个异常就会交给JVM处理，JVM处理异常的方式是，<strong>打印异常跟踪栈信息并终止程序运行</strong>，这也就是为什么程序遇到异常会自动结束的的原因）</p>
<p>throws表示出现异常的一种可能性，并不一定会发生这些异常 </p>
</blockquote>
<blockquote>
<p>throw：</p>
<p>表示方法内抛出某种异常对象，throw语句可以单独使用</p>
<p>throw语句抛出的是一个<strong>异常实例</strong>，不是一个异常类，而且每次只能抛出一个异常实例</p>
<p>执行throw一定抛出了某种异常</p>
<blockquote>
<p>关于finally的问题：</p>
<p>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止</p>
<p>如果有finally块，系统立即开始执行finally块</p>
<p>只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句</p>
<p>如果finally块里也使用了<strong>return或throw</strong>等语句，finally块会终止方法，系统将不会跳回去执行try块、catch块里的任何代码</p>
<p>这将会导致try块、catch块中的return、throw语句失效，所以，我们应该尽量避免在finally块中使用return或throw</p>
</blockquote>
<blockquote>
<p><strong>finally代码块不执行</strong>的几种情况：</p>
<p>如果当一个线程在执行 try 语句块或者catch语句块时<strong>被打断interrupted</strong>或者<strong>被终止killed</strong>，与其相对应的 finally 语句块可能不会执行</p>
<p>如果在<strong>try块或catch块中使用 <code>System.exit(1);</code></strong> 来退出虚拟机，则finally块将失去执行的机会</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><ul>
<li>特点：单线程可以处理多个用户请求</li>
<li>优势：系统开销小</li>
</ul>
<blockquote>
<p>在I&#x2F;O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I&#x2F;O多路复用技术进行处理</p>
<p>I&#x2F;O多路复用技术通过把多个I&#x2F;O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</p>
<p>与传统的多线程&#x2F;多进程模型比，I&#x2F;O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源</p>
<p>目前支持I&#x2F;O多路复用的系统调用有<code>select、pselect、poll、epoll</code>，在Linux网络编程过程中，很长一段时间都使用select做轮询和网络事件通知，然而select的一些固有缺陷导致了它的应用受到了很大的限制，最终Linux不得不在新的内核版本中寻找select的替代方案，最终选择了<code>epoll</code></p>
</blockquote>
<ul>
<li><p><code>epoll</code>与<code>select</code></p>
<blockquote>
<p>两者的原理比较类似，为了克服<code>select</code>的缺点，<code>epoll</code>作了很多重大改进：</p>
<blockquote>
<p>支持一个进程打开的socket描述符（FD）不受限制 select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由<code>FD_SETSIZE</code>设置，默认值是1024</p>
<p>对于那些需要支持上万个TCP连接的大型服务器来说显然太少了</p>
<p>可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降</p>
<p>我们也可以通过选择多进程的方案（传统的Apache方案）解决这个问题，不过虽然在Linux上创建进程的代价比较小，但仍旧是不可忽视的，另外，进程间的数据交换非常麻烦，对于Java由于没有共享内存，需要通过Socket通信或者其他方式进行数据同步，这带来了额外的性能损耗，增加了程序复杂度，所以也不是一种完美的解决方案</p>
<p>值得庆幸的是，<code>epoll</code>并没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远远大于1024</p>
<p>例如，在<code>1GB</code>内存的机器上大约是10万个句柄左右，具体的值可以通过<code>cat /proc/sys/fs/file- max</code>察看，通常情况下这个值跟系统的内存关系比较大</p>
</blockquote>
<blockquote>
<p>I&#x2F;O效率不会随着FD数目的增加而线性下降 传统的select&#x2F;poll另一个致命弱点就是当你拥有一个很大的socket集合，由于网络延时或者链路空闲，任一时刻只有少部分的socket是“活跃”的，但是select&#x2F;poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降</p>
<p><code>epoll</code>不存在这个问题，它只会对“活跃”的socket进行操作-这是因为在内核实现中<code>epoll</code>是根据每个FD上面的callback函数实现的，那么，只有“活跃”的socket才会主动的去调用callback函数，其他idle状态socket则不会。在这点上，<code>epoll</code>实现了一个伪I&#x2F;O</p>
<p>针对<code>epoll</code>和<code>select</code>性能对比的benchmark测试表明：如果所有的socket都处于活跃态</p>
<p>例如一个高速LAN环境，<code>epoll</code>并不比select&#x2F;poll效率高太多</p>
<p>相反，如果过多使用<code>epoll_ctl</code>，效率相比还有稍微的下降</p>
<p>但是一旦使用idle connections模拟WAN环境，<code>epoll</code>的效率就远在select&#x2F;poll之上了</p>
</blockquote>
<blockquote>
<p>使用<code>mmap</code>加速内核与用户空间的消息传递 无论是<code>select</code>，<code>poll</code>还是<code>epoll</code>都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，<code>epoll</code>是通过内核和用户空间<code>mmap</code>同一块内存实现</p>
</blockquote>
<blockquote>
<p><code>epoll</code>的<code>API</code>更加简单 包括创建一个<code>epoll</code>描述符、添加监听事件、阻塞等待所监听的事件发生，关闭<code>epoll</code>描述符等</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li><p>Spring框架包含众多模块，如<code>Core、Testing、Data Access、Web Servlet</code>等，其中Core是整个Spring框架的核心模块</p>
<blockquote>
<p>Core模块提供了<code>IoC</code>容器、<code>AOP</code>功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是<strong>建立在<code>IoC</code>和<code>AOP</code>之上</strong>的，所以<code>IoC</code>和<code>AOP</code>是Spring<strong>框架的核心</strong></p>
<blockquote>
<p><code>AOP（Aspect Oriented Programing）</code>是<strong>面向切面编程思想</strong>，这种思想是对<code>OOP</code>的补充，它可以在<code>OOP</code>的基础上进一步提高编程的效率</p>
<p>简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）</p>
<p>在<code>AOP</code>思想下，我们可以将解决共性需求的代码独立出来，然后<strong>通过配置的方式</strong>，声明这些代码在什么地方、什么时机调用</p>
<p>当满足调用条件时，<code>AOP</code>会将该业务代码<strong>织入到我们指定的位置</strong>，从而统一解决了问题，又不需要修改这一批组件的代码</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul>
<li><p>singleton、prototype、request、session、globalSession</p>
<blockquote>
<p>在默认情况下，Bean在Spring容器中是单例的，但我们可以通过@Scope注解来修改Bean的作用域</p>
<p>这个注解有五个不同的取值，代表了Bean的五种不同类型作用域</p>
<p>singleton ：在Spring容器中仅存在一个实例，即Bean以单例的形式存在</p>
<p>prototype ：每次调用getBean()时，都会执行new操作，返回一个新的实例</p>
<p>request ：每次HTTP请求都会创建一个新的Bean</p>
<p>session ：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean</p>
<p>globalSession：同一个全局的Session共享一个Bean，一般用于Portlet环境</p>
</blockquote>
</li>
<li><p>实现自定义Scope类</p>
<blockquote>
<p>将自定义scope集成到Spring容器当中就必须要实现org.springframework.beans.factory.config.Scope这个接口</p>
<p>接口中有两个常用的方法，分别用于底层存储机制获取和删除这个对象</p>
<p>注册新的作用域 在实现一个或多个自定义Scope并测试通过之后，接下来便是如何让Spring容器来识别新的作用域</p>
<p>registerScope方法就是在Spring容器中用来注册新的作用域，这个方法有两个参数：</p>
<p>第一个参数是与作用域相关的全局唯一的名称，第二个参数是准备实现的作用域的实例，就是实现Scope接口的实例</p>
<p>使用自定义的Scope 要使用自定义的Scope，开发者不仅可以通过编程的方式来实现自定义bean作用域，也可以通过在xml中配置和使用自定义作用域</p>
</blockquote>
</li>
</ul>
<h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><ul>
<li><p>一个是Factory，也就是IoC容器或对象工厂，一个是Bean</p>
<blockquote>
<p>在Spring中，所有的Bean都是由BeanFactory（也就是IoC容器）来进行管理的</p>
<p>但对<strong>FactoryBean</strong>而言，是一个<strong>能产生或者修饰对象生成的工厂Bean</strong>，它的实现与设计模式中的<strong>工厂模式和修饰器模式类似</strong></p>
<p>用户使用容器时，可以使用转义符“＆”(z‘da)来得到FactoryBean本身，用来区分获取FactoryBean产生的对象和获取FactoryBean本身</p>
<p>举例来说，如果alphaObject是一个FactoryBean，那么使用＆alphaObject得到的是FactoryBean，而不是alphaObject这个FactoryBean产生出来的对象</p>
<p>其中，alphaObject是定义Bean的时候所指定的名字</p>
</blockquote>
</li>
<li><p>BeanFactory定义方法：</p>
<blockquote>
<p>getBean(String name): Spring容器中获取对应Bean对象的方法，如存在，则返回该对象</p>
<p>containsBean(String name)：Spring容器中是否存在该对象</p>
<p>isSingleton(String name)：通过beanName是否为单例对象</p>
<p>isPrototype(String name)：判断bean对象是否为多例对象</p>
<p>isTypeMatch(String name，ResolvableType typeToMatch):判断name值获取出来的bean与typeToMatch是否匹配</p>
<p>getType(String name)：获取Bean的Class类型</p>
<p>getAliases(String name):获取name所对应的所有的别名 </p>
</blockquote>
</li>
<li><p>FactoryBean方法：</p>
<blockquote>
<p>T getObject()：返回实例</p>
<p>Class getObjectType():返回该装饰对象的Bean的类型</p>
<p>default boolean isSingleton():Bean是否为单例</p>
</blockquote>
</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul>
<li><p><code>IoC（Inversion of Control）</code>是<strong>控制反转</strong>的意思，这是一种面向对象编程的设计思想</p>
<blockquote>
<p>在不采用这种思想的情况下，我们需要自己<strong>维护对象与对象之间的依赖关系</strong>，很<strong>容易造成对象之间的耦合度过高</strong></p>
<p><code>IoC</code>则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度</p>
<p>说到<code>IoC</code>就不得不说DI（Dependency Injection），DI是<strong>依赖注入</strong>的意思，它是<code>IoC</code>实现的实现方式，</p>
<p>由于<code>IoC</code>这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将<code>IoC</code>和DI划等号</p>
<p>而实现依赖注入的关键是<code>IoC</code>容器，它的<strong>本质就是一个工厂</strong></p>
</blockquote>
</li>
<li><p><code>IOC</code>与<code>EJB</code></p>
<blockquote>
<p>在以Spring为代表的轻量级<code>Java EE</code>开发风行之前，实际开发中是使用更多的是<code>EJB</code>为代表的开发模式</p>
<p>在<code>EJB</code>开发模式中，开发人员需要编写<code>EJB</code>组件，这种组件需要满足<code>EJB</code>规范才能在<code>EJB</code>容器中运行，从而完成获取事务，生命周期管理等基本服务</p>
<p>Spring提供的服务和<code>EJB</code>并没有什么区别，只是在具体怎样获取服务的方式上两者的设计有很大不同：<code>Spring IoC</code>提供了一个基本的<code>JavaBean</code>容器，通过<code>IoC</code>模式管理依赖关系，并通过依赖注入和<code>AOP</code>切面增强了为<code>JavaBean</code>这样的<code>POJO</code>对象服务于事务管理、生命周期管理等基本功能</p>
<p>而对于<code>EJB</code>，一个简单的<code>EJB</code>组件需要编写<strong>远程／本地接口</strong>、<strong>Home接口</strong>和<strong>Bean的实体类</strong>，而且<code>EJB</code>运行不能脱离<code>EJB</code>容器，查找其他<code>EJB</code>组件也需要通过诸如<code>JNDI</code>的方式，这就造成了对<code>EJB</code>容器和技术规范的依赖</p>
<p>也就是说Spring把<code>EJB</code>组件还原成了<code>POJO</code>对象或者<code>JavaBean</code>对象，以此降低了应用开发对于传统<code>J2EE</code>技术规范的依赖</p>
<p>在应用开发中开发人员设计组件时往往需要引用和调用其他组件的服务，这种依赖关系如果固化在组件设计中，会造成依赖关系的僵化和维护难度的增加，这个时候使用<code>IoC</code>把资源获取的方向反转，让<code>IoC</code>容器主动管理这些依赖关系，将这些依赖关系注入到组件中，这就会让这些依赖关系的适配和管理更加灵活</p>
</blockquote>
</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul>
<li><p><code>AOP</code>是一种编程思想，是通过<strong>预编译方式</strong>和<strong>运行期动态代理</strong>的方式实现不修改源代码的情况下给程序<strong>动态统一添加功能</strong>的技术</p>
<blockquote>
<p>面向对象编程将程序<strong>抽象成各个层次的对象</strong>，而面向切面编程是将程序<strong>抽象成各个切面</strong></p>
<p>所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块</p>
<p>AOP技术利用一种称为“横切”的技术，<strong>剖解开封装对象的内部</strong>，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为切面</p>
<p>所谓的切面，简单来说就是与业务无关，却为业务模块所共同调用的逻辑，将其封装起来便于减少系统的重复代码，降低模块的耦合度，有利用未来的可操作性和可维护性</p>
</blockquote>
</li>
<li><p>实现方式：<strong>JDK动态代理、CGLib动态代理</strong></p>
<blockquote>
<p>JDK动态代理：这是Java提供的动态代理技术，可以在运行时<strong>创建接口的代理实例</strong></p>
<p>Spring AOP默认采用这种方式，在<strong>接口的代理实例</strong>中织入代码</p>
<p>CGLib动态代理：采用<strong>底层的字节码技术</strong>，在运行时<strong>创建子类代理的实例</strong></p>
<p>当<strong>目标对象不存在接口</strong>时，Spring AOP就会采用这种方式，在<strong>子类实例</strong>中织入代码</p>
</blockquote>
</li>
<li><p>注意</p>
<blockquote>
<p>在应用场景方面，Spring AOP为IoC的使用提供了更多的便利</p>
<p>应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能</p>
<p>在Spring内部，例如事务处理之类的一些支持模块也是通过Spring AOP来实现的</p>
<p>AOP不能增强的类： </p>
<p>Spring AOP只能对<strong>IoC容器中的Bean进行增强</strong>，对于不受容器管理的对象不能增强</p>
<p>由于CGLib采用<strong>动态创建子类</strong>的方式生成代理对象，所以<strong>不能对final修饰的类进行代理</strong></p>
</blockquote>
</li>
</ul>
<h3 id="Autowired和-Resource注解"><a href="#Autowired和-Resource注解" class="headerlink" title="@Autowired和@Resource注解"></a>@Autowired和@Resource注解</h3><ul>
<li><p>@Autowired是<strong>Spring提供的注解</strong>，@Resource是<strong>JDK提供的注解</strong></p>
<blockquote>
<p>@Autowired是只能<strong>按类型注入</strong>，@Resource<strong>默认按名称注入</strong>，也<strong>支持按类型注入</strong></p>
<p>@Autowired按类型装配依赖对象，<strong>默认情况下它要求依赖对象必须存在</strong>，如果<strong>允许null值，可以设置它required属性为false</strong>，如果我们<strong>想使用按名称装配，结合@Qualifier注解一起使用</strong></p>
<p>@Resource有两个中重要的属性：name和type，<strong>name属性指定byName</strong>，如果<strong>没有指定name属性</strong>，当<strong>注解标注在字段</strong>上，即<strong>默认取字段的名称作为bean名称寻找依赖对象</strong>，当注<strong>解标注在属性的setter方法上</strong>，即<strong>默认取属性名作为bean名称寻找依赖对象</strong></p>
</blockquote>
</li>
<li><p>@Resource装配顺序</p>
<blockquote>
<p>如果<strong>同时指定了name和type</strong>，则<strong>从Spring上下文中找到唯一匹配的bean进行装配</strong>，找不到则抛出异常</p>
<p>如果<strong>指定了name，则从上下文中查找名称（id）匹配的bean进行装配</strong>，找不到则抛出异常</p>
<p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，<strong>找不到或者找到多个，都会抛出异常</strong></p>
<p>如果既<strong>没有指定name，又没有指定type</strong>，则<strong>自动按照byName方式进行装配</strong></p>
<p>如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配</p>
</blockquote>
</li>
</ul>
<h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><ul>
<li><p>Spring支持两种事务编程模型：</p>
</li>
<li><p>编程式事务</p>
<blockquote>
<p><strong>Spring提供了TransactionTemplate模板</strong>，利用该模板我们可以通过编程的方式实现事务管理，而<strong>无需关注资源获取、复用、释放、事务同步及异常处理等操作</strong></p>
<p>相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为<strong>灵活</strong>，我们可以将<strong>事务管理的范围控制的更为精确</strong></p>
</blockquote>
</li>
<li><p>声明式事务</p>
<blockquote>
<p>Spring事务管理的<strong>亮点在于声明式事务管理</strong>，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性</p>
<p>相对于编程式事务来说，这种方式十分的方便，只需要<strong>在需要做事务管理的方法上，增加@Transactional注解</strong>，以声明事务特征即可</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器</p>
<p>在Spring Boot中，当你添加了数据库访问框架的起步依赖时，它就会进行自动配置，即自动实例化正确的事务管理器</p>
<p>对于声明式事务，是使用@Transactional进行标注的，这个注解可以标注在类或者方法上</p>
<p>当它<strong>标注在类上</strong>时，代表这个类<strong>所有公共（public）非静态的方法都将启用事务功能</strong></p>
<p>当它<strong>标注在方法上</strong>时，<strong>代表这个方法将启用事务功能</strong></p>
<p>在@Transactional注解上，我们可以<strong>使用isolation属性声明事务的隔离级别</strong>，使用propagation属性声明事务的传播机制</p>
</blockquote>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li><p>MVC是一种<strong>设计模式</strong></p>
<blockquote>
<p>在这种模式下软件被分为三层，即Model（模型）、View（视图）、Controller（控制器）</p>
<p><strong>Model代表的是数据</strong>，<strong>View代表的是用户界面</strong>，<strong>Controller代表的是数据的处理逻辑</strong>，它是Model和View这两层的桥梁，将软件分层的好处是，可以将<strong>对象之间的耦合度降低</strong>，便于代码的维护</p>
<p>Model：指从现实世界中抽象出来的对象模型，是应用逻辑的反应，它封装了数据和对数据的操作，是实际进行数据处理的地方（模型层与数据库才有交互）</p>
<p>在MVC的三个部件中，模型拥有最多的处理任务，被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</p>
<p>View：负责进行模型的展示，一般就是我们见到的用户界面</p>
<p>Controller：控制器<strong>负责视图和模型之间的交互</strong>，控制<strong>对用户输入的响应、响应方式和流程</strong></p>
<p>它主要负责两方面的动作，一是把用户的<strong>请求分发到相应的模型</strong>，二是<strong>把模型的改变及时地反映到视图上</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>为了解耦以及提升代码的可维护性，服务端开发一般会对代码进行分层，服务端代码一般会分为三层：<strong>表现层、业务层、数据访问层</strong></p>
<p>在浏览器访问服务器时，请求会先到达表现层 <strong>最典型的MVC就是jsp+servlet+javabean模式</strong></p>
<p>以<strong>JavaBean作为模型</strong>，既可以<strong>作为数据模型来封装业务数据</strong>，又可以<strong>作为业务逻辑模型来包含应用的业务操作</strong></p>
<p><strong>JSP作为视图层</strong>，负责提供页面为用户展示数据，提供相应的表单（Form）来用于用户的请求，并在适当的时候（点击按钮）<strong>向控制器发出请求来请求模型进行更新</strong></p>
<p><strong>Serlvet作为控制器</strong>，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图</p>
<p>当然，这种方式现在已经不那么流行了，Spring MVC框架已经成为了MVC模式的最主流实现</p>
<p>Spring MVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架</p>
<p><strong>前端控制器是DispatcherServlet接口实现类</strong>，<strong>映射处理器是HandlerMapping接口实现类</strong>，<strong>视图解析器是ViewResolver接口实现类</strong>，<strong>页面控制器是Controller接口实现类</strong></p>
</blockquote>
<h4 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h4><ul>
<li><p>SpringMVC 的执行流程如下</p>
<blockquote>
<p>用户点击某个请求路径，发起一个 HTTP request 请求，该<strong>请求被提交到前端控制器</strong>(DispatcherServlet)</p>
<p>由 DispatcherServlet <strong>请求一个或多个处理器映射器</strong>(HandlerMapping)，并<strong>返回一个执行链</strong>(HandlerExecutionChn)</p>
<p>DispatcherServlet <strong>将执行链返回的 Handler 信息</strong>发送给<strong>处理器适配器</strong>(HandlerAdapter)</p>
<p>HandlerAdapter 根据 Handler 信息<strong>找到并执行相应的 Handler(常称为 Controller)</strong></p>
<p>Handler 执行完毕后会<strong>返回给 HandlerAdapter 一个 ModelAndView 对象</strong>(Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息)</p>
<p>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet </p>
<p>DispatcherServlet 接收到 ModelAndView 对象后，<strong>会请求视图解析器(ViewResolver)对视图进行解析</strong></p>
<p>ViewResolver <strong>根据 View 信息匹配到相应的视图结果</strong>，并返回给 DispatcherServlet</p>
<p>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，<strong>将 Model 中的模型数据填充到 View 视图中的 request 域</strong>，生成最终的 View(视图)</p>
<p>视图负责将结果显示到浏览器(客户端)</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220902153317123.png" alt="image-20220902153317123"></p>
</blockquote>
</li>
</ul>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul>
<li><p>这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期</p>
</li>
<li><p>Bean 生命周期大致分为 <strong>Bean 定义</strong>、Bean实例化、Bean属性赋值、<strong>Bean 的初始化</strong>、<strong>Bean的生存期</strong>和 <strong>Bean 的销毁</strong>六个部分</p>
</li>
</ul>
<blockquote>
<p><strong>Spring启动</strong>，<strong>查找并加载需要被Spring管理的bean</strong>，<strong>进行Bean的实例化</strong></p>
<p>Bean实例化后对将Bean的引入和值注入到Bean的属性中</p>
<p>SpringBean生命周期中的增强接口PostProcessor；postProcessBeforeInitialization方法执行前，会执行很多<strong>Aware类型的接口</strong>，这种类型接口作用是<strong>加载资源到Spring容器中</strong></p>
<blockquote>
<p>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p>
<p>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p>
<p>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</p>
</blockquote>
<p>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法</p>
<p><strong>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法，类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</strong></p>
<p>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法</p>
<p>此时，Bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到应用上下文被销毁，至于销毁，是在容器关闭时调用的</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用</p>
</blockquote>
<blockquote>
<p>这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预</p>
<p>可以<strong>自定义初始化方法</strong>，并在该方法前增加**@PostConstruct注解<strong>，届时Spring容器将在调用</strong>SetBeanFactory方法之后**调用该方法</p>
<p>可以<strong>自定义销毁方法</strong>，并在该方法前增加**@PreDestroy注解<strong>，届时</strong>Spring容器将在自身销毁前调用这个方法**</p>
</blockquote>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="在MyBatis中-和-的区别"><a href="#在MyBatis中-和-的区别" class="headerlink" title="在MyBatis中$和#的区别"></a>在MyBatis中$和#的区别</h4><ul>
<li><p>使用**${}拼接符设置参数<strong>时，MyBatis会</strong>创建普通的SQL语句<strong>，然后在</strong>执行SQL 语句时将参数拼入SQL**</p>
<blockquote>
<p>${} 为字符串替换，即 sql 拼接</p>
<p>${}：动态解析 -&gt; 编译 -&gt; 执行</p>
<p>${} 的变量替换是在 DBMS 外</p>
<p>变量替换后，${} 对应的变量不会加上单引号 ‘’</p>
<p>${} 不能防止sql 注入</p>
<p>举例：</p>
<p>${}：select * from t_user where uid&#x3D; ‘${uid}’</p>
<p>${}：select * from t_user where uid&#x3D; ‘1’</p>
<p>${}：select * from t_user where uid&#x3D; ‘1’</p>
</blockquote>
</li>
<li><p>使用**#{}占位符设置参数<strong>时，MyBatis会</strong>创建预编译的SQL语句<strong>，然后在</strong>执行SQL时MyBatis会为预编译SQL中的占位符赋值**</p>
<blockquote>
<p>#{}：为参数占位符 ?，即sql 预编译</p>
<p>#{}：动态解析 -&gt; 预编译 -&gt; 执行</p>
<p>#{}：的变量替换是在DBMS 中</p>
<p>变量替换后，#{} 对应的变量自动加上单引号 ‘’</p>
<p>#{} 能防止sql 注入</p>
<p>举例：</p>
<p>#{}：select * from t_user where uid&#x3D;#{uid}</p>
<p>#{}：select * from t_user where uid&#x3D; ?</p>
<p>#{}：select * from t_user where uid&#x3D; ‘1’</p>
<p><strong>预编译的SQL语句执行效率高</strong>，并且可以<strong>防止注入攻击</strong>，效率和安全性都大大优于前者</p>
<p>但在解决一些特殊问题，如在一些根据不同的条件产生不同的动态列中，我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL就只能使用$了</p>
<blockquote>
<p><strong>表名作参数</strong>时，必须用 ${}，如：select * from ${tableName}</p>
<p><strong>order by</strong> 时，必须用 ${}，如：select * from t_user order by ${columnName}</p>
<p>使用 ${} 时，要注意何时加或不加单引号，即 ${} 和 ‘${}’</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="Mybatis缓存机制"><a href="#Mybatis缓存机制" class="headerlink" title="Mybatis缓存机制"></a>Mybatis缓存机制</h4><ul>
<li><p><strong>一级缓存</strong>也称为<strong>本地缓存</strong>，它<strong>默认启用且不能关闭</strong></p>
<blockquote>
<p>一级缓存<strong>存在于SqlSession的生命周期中</strong>，即它是SqlSession级别的缓存</p>
<p>在<strong>同一个 SqlSession 中查询</strong>时，MyBatis 会把<strong>执行的方法和参数</strong>通过算法<strong>生成缓存的键值</strong>，将<strong>键值和查询结果存入一个Map对象中</strong></p>
<p>如果<strong>同一个SqlSession 中执行的方法和参数完全一致</strong>，那么通过算法<strong>会生成相同的键值</strong>，当Map<strong>缓存对象中己经存在该键值</strong>时，则会<strong>返回缓存中的对象</strong></p>
</blockquote>
</li>
<li><p>二级缓存<strong>存在于SqlSessionFactory 的生命周期中</strong>，即它是SqlSessionFactory级别的缓存</p>
<blockquote>
<p>若想使用二级缓存，需要在如下两处进行配置：</p>
<p>在MyBatis 的全局配置settings 中有一个参数<strong>cacheEnabled</strong>，这个参数是二级缓存的全局开关，默认值是true ，初始状态为启用状态</p>
<p>MyBatis 的<strong>二级缓存是和命名空间绑定的</strong>，即二级缓存<strong>需要配置在Mapper.xml 映射文件中</strong></p>
<p>在保证二级缓存的全局配置开启的情况下，给Mapper.xml 开启二级缓存需要在Mapper. xml 中添加如下代码: </p>
<p>二级缓存具有如下效果。</p>
<p>映射语句文件中的<strong>所有SELECT 语句将会被缓存</strong></p>
<p>映射语句文件中的<strong>所有的INSERT 、UPDATE 、DELETE 语句会刷新缓存</strong></p>
<p>缓存会使用<strong>LRU算法</strong>(Least Recently Used，最近最少使用的）来收回</p>
<p>根据时间表（如no Flush Interval ，没有刷新间隔），<strong>缓存不会以任何时间顺序来刷新</strong></p>
<p>缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用</p>
<p>缓存会被视为read&#x2F;write（可读／可写）的，意味着<strong>对象检索不是共享的</strong>，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改</p>
</blockquote>
</li>
<li><p>Mybatis 一级缓存失效的四种情况：</p>
<blockquote>
<p><strong>sqlsession变了</strong>，缓存失效</p>
<p>sqlsession不变，<strong>查询条件不同</strong>，一级缓存失效</p>
<p>sqlsession不变，<strong>中间发生了增删改操作</strong>，一级缓存失败</p>
<p>sqlsession不变，<strong>手动清除缓存</strong>，一级缓存失败</p>
<p>注意：当其它sqlsession对数据库进行了增删改查操作并不会使其他sqlsession的缓存失效</p>
</blockquote>
</li>
<li><p>MyBatis的二级缓存(在一级缓存的基础上采用了装饰者设计模式)</p>
<blockquote>
<p>二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强</p>
<p>MyBatis在多表查询时，极大可能会出现脏数据，这导致安全使用二级缓存的条件比较苛刻</p>
<blockquote>
<p><strong>通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于namespace的，多表查询语句所在的namspace无法感应到其他namespace中的语句对多表查询中涉及的表进行的修改，引发脏数据问题</strong></p>
</blockquote>
<p>由于默认的MyBatis Cache实现都是基于本地的，这导致在分布式环境下，一定会出现读取到脏数据的情况，且开发成本较高，所以开发环境中一般都会直接使用Redis，Memcached等分布式缓存</p>
<p>注：当开启事务时，执行完查询语句后<strong>没有提交事务不会改变缓存</strong></p>
</blockquote>
</li>
<li><p>缓存工作过程</p>
<blockquote>
<p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache</p>
<p>当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户</p>
</blockquote>
<blockquote>
<p>开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示</p>
<img src="https://img-blog.csdnimg.cn/img_convert/d6c26792e8b2a1613d972c47bb203663.png" alt="img" style="zoom:67%;" />

<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量</p>
<p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库</p>
</blockquote>
</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul>
<li><p>SpringBoot与Spring的关系</p>
<blockquote>
<p>其实从本质上来说，<strong>Spring Boot就是Spring</strong>，它<strong>帮你完成了一些Spring Bean配置</strong></p>
<p>Spring Boot使用<strong>“习惯优于配置”</strong>的理念让你的项目快速地运行起来，使用Spring Boot能很快的创建一个能独立运行、准生产级别、基于Spring框架的项目</p>
<p>但<strong>Spring Boot本身不提供Spring的核心功能</strong>，而是<strong>作为Spring的脚手架</strong>框架，达到<strong>快速构建项目，预设第三方配置，开箱即用</strong>的目的</p>
<p>Spring Boot有很多优点，具体如下：</p>
<blockquote>
<p>可以<strong>快速构建项目</strong></p>
<p>可以<strong>对主流开发框架的无配置集成</strong></p>
<p>项目<strong>可独立运行，无需外部依赖Servlet容器</strong></p>
<p>提供运行时的应用监控</p>
<p>可以极大地提高开发、部署效率</p>
<p>可以与云计算天然集成</p>
</blockquote>
</blockquote>
</li>
<li><p>Spring Boot 的核心功能：</p>
<blockquote>
<p><strong>自动配置</strong> 针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置</p>
<p><strong>起步依赖</strong> Spring Boot通过起步依赖为项目的依赖管理提供帮助，起步依赖其实就是特殊的Maven依赖和Gradle依赖，利用了<strong>传递依赖解析</strong>，把<strong>常用库聚合在一起</strong>，组成了几个<strong>为特定功能而定制的依赖</strong></p>
<p><strong>端点监控</strong> Spring Boot 可以<strong>对正在运行的项目提供监控</strong></p>
</blockquote>
</li>
</ul>
<h4 id="SpringBoot启动依赖"><a href="#SpringBoot启动依赖" class="headerlink" title="SpringBoot启动依赖"></a>SpringBoot启动依赖</h4><blockquote>
<p>Spring Boot <strong>将日常企业应用研发中的各种场景都抽取出来</strong>，做成一个个的 <strong>starter</strong>（启动器），starter 中整合了该场景下<strong>各种可能用到的依赖</strong>，用户只需要<strong>在 Maven 中引入 starter 依赖</strong>，SpringBoot 就能<strong>自动扫描到要加载的信息并启动相应的默认配置</strong></p>
<p>starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰</p>
<p>所有这些 <strong>starter 都遵循着约定成俗的默认配置</strong>，并允许用户调整这些配置，即遵循“<strong>约定大于配置</strong>”的原则</p>
<p>以 spring-boot-starter-web 为例，它能够为提供 Web 开发场景所需要的几乎所有依赖，因此在使用 Spring Boot 开发 Web 项目时，只需要引入该 Starter 即可，而不需要额外导入 Web 服务器和其他的 Web 依赖</p>
</blockquote>
<blockquote>
<p>在引入starter时，我们并不需要指明版本（version），这是因为starter版本信息是由 spring-boot-starter-parent（版本仲裁中心） 统一控制的</p>
</blockquote>
<h4 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h4><blockquote>
<p>当Spring Boot项目创建完成后会<strong>默认生成一个Application的入口类</strong>，这个类中的<strong>main方法可以启动Spring Boot项目</strong>，在main方法中，<strong>通过SpringApplication的静态方法(run方法)<strong>进行</strong>SpringApplication的实例化操作</strong>，然后<strong>再针对实例化对象调用另外一个run方法</strong>来完成<strong>整个项目的初始化和启动</strong></p>
<p>SpringApplication调用的run方法重点做了以下操作：</p>
<p><strong>获取监听器参数配置</strong></p>
<p>打印Banner信息</p>
<p><strong>创建并初始化容器</strong></p>
<p><strong>监听器发送通知</strong> </p>
</blockquote>
<blockquote>
<p>SpringApplication实例化过程中相对重要的配置：</p>
<p>项目启动类 SpringbootDemoApplication.class 设置为属性存储起来 this.primarySources &#x3D; new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources))</p>
<p>设置应用类型是 SERVLET 应用还是 REACTIVE 应用 this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath()</p>
<p>设置初始化器(Initializer)，最后会调用这些初始化器</p>
<p>所谓的初始化器就是 org.springframework.context.ApplicationContextInitializer 的实现类，在 Spring 上下文被刷新之前进行初始化的操作 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class))</p>
<p>设置监听器(Listener) setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))</p>
<p>初始化 mnApplicationClass 属性:用于推断并设置项目 main()方法启动的主程序启动类 this.mnApplicationClass &#x3D; deduceMnApplicationClass();</p>
</blockquote>
<h4 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h4><ul>
<li><p>使用Spring Boot时，我们需要<strong>引入对应的Starters</strong>，<strong>Spring Boot启动时</strong>便会<strong>自动加载相关依赖</strong>，<strong>配置相应的初始化参数</strong>，以最快捷、简单的形式<strong>对第三方软件进行集成</strong>，这便是Spring Boot的自动配置功能</p>
<blockquote>
<p>整个自动装配的过程是：</p>
<p>Spring Boot<strong>通过@EnableAutoConfiguration注解开启自动配置</strong>，加载<strong>spring.factories中注册的各种AutoConfiguration类</strong>，当某个<strong>AutoConfiguration类满足其注解@Conditional指定的生效条件</strong>时，<strong>实例化该AutoConfiguration类中定义的Bean</strong>（组件等），并<strong>注入Spring容器</strong>，就可以完成依赖框架的自动配置</p>
<p>@EnableAutoConfiguration 作用 <strong>从classpath中搜索所有META-INF&#x2F;spring.factories配置文件</strong></p>
<p>然后，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器</p>
<p>只有spring.boot.enableautoconfiguration为true（默认为true）的时候，才启用自动配置 @EnableAutoConfiguration还有俩个方法exclude()、excludeName()，可以根据class来排除（exclude），或是根据class name（excludeName）来排除</p>
<blockquote>
<p>其内部实现的关键点有</p>
<p>ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中，SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF&#x2F;spring.factories配置文件，并读取配置</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="SpringBoot常用注解"><a href="#SpringBoot常用注解" class="headerlink" title="SpringBoot常用注解"></a>SpringBoot常用注解</h4><ul>
<li><p>Spring Boot常用注解：</p>
<blockquote>
<p><strong>@SpringBootApplication注解</strong>， 在Spring Boot入口类中，@SpringBootApplication，它是<strong>Spring Boot项目的核心注解</strong>，用于开启自动配置，准确说是<strong>通过该注解内组合的@EnableAutoConfiguration开启了自动配置</strong></p>
<p><strong>@EnableAutoConfiguration注解</strong>，@EnableAutoConfiguration的主要功能是<strong>启动Spring应用程序上下文时进行自动配置</strong>，它会<strong>尝试猜测并配置项目可能需要的Bean</strong>，自动配置通常是基于项目<strong>classpath中引入的类和已定义的Bean</strong>来实现的，在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中</p>
<p><strong>@Import注解</strong>，@EnableAutoConfiguration的关键功能是<strong>通过@Import注解导入的AutoConfigurationImportSelector来完成的</strong>，从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是<strong>自动配置功能的核心实现者</strong></p>
<p><strong>@Conditional注解</strong>，@Conditional注解是由Spring 4.0版本引入的新特性，可<strong>根据是否满足指定的条件来决定是否进行Bean的实例化及装配</strong>，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作</p>
</blockquote>
</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="数据库底层数据结构"><a href="#数据库底层数据结构" class="headerlink" title="数据库底层数据结构"></a>数据库底层数据结构</h3><ul>
<li><p>为什么不用红黑树而用B+树</p>
<blockquote>
<p>红黑树是一种近似平衡二叉树（不完全平衡），结点非黑即红的树，它的树高最高不会超过 2*log(n)，因此**查找的时间复杂度为 O(log(n))**，无论是增删改查，它的性能都十分稳定</p>
<p>红黑树<strong>本质还是二叉树</strong>，在数据量非常大时，需要访问+判断的节点数还是会比较多，同时数据是存在磁盘上的，访问需要进行磁盘IO，导致效率较低</p>
<p>B+树是多叉的，可以有效减少磁盘IO次数，同时B+树<strong>增加了叶子结点间的连接</strong>，能保证<strong>范围查询时找到起点和终点后快速取出需要的数据</strong></p>
</blockquote>
</li>
</ul>
<h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><ul>
<li><p>InnoDB引擎</p>
<blockquote>
<p>MySQL 的事务安全（ACID 兼容）存储引擎，具有<strong>提交、回滚和崩溃恢复功能</strong>来保护用户数据</p>
<p><strong>行级锁定读取</strong>增加了多用户并发性和性能</p>
<p>将<strong>用户数据存储在聚集索引</strong>中，以减少基于主键的常见查询的 I&#x2F;O</p>
<p>还支持外键 (FOREIGN KEY) 维护数据完整性</p>
</blockquote>
</li>
<li><p>MyISAM引擎的表占用空间较小，<strong>表级锁定限制了读&#x2F;写工作负载的性能</strong>，因此它<strong>通常用于只读或以读取为主的场景</strong></p>
</li>
<li><p>Memory引擎是将<strong>所有数据存储在 RAM 中</strong>，以便在需要快速查找非关键数据的环境中进行快速访问，以前被称为 HEAP 引擎</p>
</li>
<li><p>Archive引擎非常适合存储大量的独立的，作为历史记录的数据，因为它们不经常被读取，它<strong>拥有高效的插入速度，但其对查询的支持相对较差</strong></p>
</li>
<li><p>Cluster&#x2F;NDB是高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性，适合数据量大，安全和性能要求高的应用</p>
</li>
<li><p>Federated引擎提供连接单独的 MySQL 服务器，从<strong>多个物理服务器创建一个逻辑数据库</strong>的能力，非常<strong>适合分布式或数据集市环境</strong></p>
</li>
</ul>
<h4 id="innoDB和myisam的区别"><a href="#innoDB和myisam的区别" class="headerlink" title="innoDB和myisam的区别"></a>innoDB和myisam的区别</h4><ul>
<li><p>InnoDB是具有<strong>事务、回滚和崩溃修复能力</strong>的<strong>事务安全型引擎</strong>，它可以实现<strong>行级锁来保证高性能的大量数据中的并发操作</strong></p>
</li>
<li><p>MyISAM是具有<strong>默认支持全文索引</strong>、<strong>压缩功能</strong>及<strong>较高查询性能</strong>的<strong>非事务性引擎</strong></p>
<blockquote>
<p>事务：InnoDB支持事务，MyISAM不支持</p>
<p>数据锁：InnoDB支持行级锁，MyISAM只支持表级锁</p>
<p>读写性能：InnoDB增删改性能更优，MyISAM查询性能更优</p>
<p>全文索引：InnoDB不支持（但可通过插件等方式支持），MyISAM默认支持</p>
<p>外键：<strong>InnoDB支持外键</strong>，MyISAM不支持</p>
<p>存储结构：<strong>InnoDB在磁盘存储为一个文件</strong>，<strong>MyISAM在磁盘上存储成三个文件（表定义、数据、索引）</strong></p>
<p>存储空间：InnoDB<strong>需要更多的内存和存储</strong>，MyISAM支持三种不同的存储格式：<strong>静态表(默认)、动态表、压缩表</strong></p>
<p>移植：InnoDB在数据量小时可通过拷贝数据文件、备份 binlog、mysqldump工具移植，数据量大时比较麻烦，<strong>MyISAM可单独对某个表通过拷贝表文件移植</strong></p>
<p>崩溃恢复：InnoDB有崩溃恢复机制，MyISAM没有</p>
<p>默认推荐：InnoDB是MySQL5.5之后的默认引擎</p>
</blockquote>
</li>
<li><p>InnoDB中<strong>行级锁是怎么实现</strong></p>
<blockquote>
<p>InnoDB行级锁是<strong>通过给索引上的索引项加锁</strong>来实现的</p>
<p>只有<strong>通过索引条件检索数据</strong>，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p>
<p>当表中锁定其中的某几行时，<strong>不同的事务可以使用不同的索引锁定不同的行</strong></p>
<p>另外，不论<strong>使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁</strong></p>
</blockquote>
</li>
</ul>
<h4 id="InnoDB的MVCC"><a href="#InnoDB的MVCC" class="headerlink" title="InnoDB的MVCC"></a>InnoDB的MVCC</h4><ul>
<li><p>全称 Multi-Version Concurrency Control ，即多版本并发控制，逻辑是<strong>维持一个数据的多个版本，使得读写操作没有冲突</strong></p>
<blockquote>
<p>MVCC主要是为了<strong>提高数据库并发性能</strong>，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<p>它是一种用来<strong>解决读-写冲突的无锁并发控制机制</strong></p>
<p>在并发读写数据库时，可以<strong>做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作</strong>，提高了数据库并发读写的性能，还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题</p>
<p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC即多版本的并发控制协议，它最大的优点是读不加锁，因此读写不冲突，并发性能好</p>
<p>InnoDB实现MVCC，多个版本的数据可以共存，主要<strong>基于以下技术及数据结构</strong>：</p>
<p><strong>隐藏列</strong>：InnoDB中每行数据都有隐藏列，<strong>隐藏列中包含了本行数据的事务id、指向undo log的指针</strong>等</p>
<p>基于<strong>undo log的版本链</strong>：每行数据的隐藏列中包含了指向undo log的指针，而<strong>每条undo log也会指向更早版本的undo log，从而形成一条版本链</strong></p>
<p><strong>ReadView</strong>：<strong>通过隐藏列和版本链，MySQL可以将数据恢复到指定版本</strong></p>
<p>但是具体要恢复到哪个版本，则需要根据ReadView来确定，所谓ReadView，是指<strong>事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照</strong>，之后<strong>再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较</strong>，从而<strong>判断数据对该ReadView是否可见</strong>，即对事务A是否可见</p>
</blockquote>
</li>
</ul>
<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><ul>
<li><p>索引就像指向表行的指针，是一种允许查询操作快速确定哪些行符合WHERE子句中的条件，并检索到这些行的其他列值的数据结构</p>
<blockquote>
<p>索引主要有<strong>普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引</strong>几种</p>
<p>在大数据量的查询中，合理使用索引的优点非常明显，不仅能<strong>大幅提高匹配where条件的检索效率</strong>，还<strong>能用于排序和分组操作的加速</strong></p>
<p>当时索引如果使用不当也有比较大的坏处：</p>
<p>比如索引必定会<strong>增加存储资源的消耗</strong></p>
<p>同时也<strong>增大了插入、更新和删除操作的维护成本</strong>，因为每个增删改操作后相应列的索引都必须被更新</p>
<p>只要创建了索引，就一定会走索引吗？ 不一定</p>
<p>select *</p>
<p>like 左边含有%</p>
<p>索引列有计算</p>
<p>索引列使用了函数</p>
<p>索引列类型与&#x3D;后面的类型不匹配(int &#x3D; varchar除外)</p>
<p>列对比，索引列 &#x3D; 另一个列</p>
<p>使用or，但是没有同时都建立索引</p>
<p>使用联合索引但没有满足最左匹配原则</p>
<p>数据较少mysql估计全表扫描比索引快</p>
</blockquote>
</li>
</ul>
<h4 id="数据库索引的数据结构"><a href="#数据库索引的数据结构" class="headerlink" title="数据库索引的数据结构"></a>数据库索引的数据结构</h4><ul>
<li><p>数据库索引主要有Hash表、二叉树、红黑树、B树、B+树，MySQL使用的是B+树</p>
</li>
<li><p>MySQL不使用二叉树的原因：</p>
<blockquote>
<p>二叉树<strong>在某些场景下会退化成链表</strong>，而链表的查找<strong>需要从头部开始遍历</strong>，而这就<strong>失去了加索引的意义</strong></p>
</blockquote>
</li>
<li><p>不使用红黑树的原因是：</p>
<blockquote>
<p>红黑树作为底层数据结构在面对在些表数据动辄数百万数千万的场景时，会<strong>导致索引树的层数很高</strong></p>
<p><strong>索引从根节点开始查找</strong>，而如果我们需要查找的<strong>数据在底层的叶子节点上</strong>，那么树的<strong>高度是多少</strong>，<strong>就要进行多少次查找</strong>，数据存在磁盘上，<strong>访问需要进行磁盘IO</strong>，这会导致<strong>效率过低</strong></p>
</blockquote>
</li>
<li><p>不用hash表的原因</p>
<blockquote>
<p> 哈希表的查询效率的确最高，时间复杂度O(1)，但是它<strong>要求将所有数据载入内存</strong>，而数据库存储的数据量级可能会非常大，全部载入内存基本上是不可能实现的</p>
<p>B+树可以<strong>分段加载需要的节点数据</strong>，可以在内存资源有限的前提下，极大提高查询效率</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>而B+树由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接</p>
<p>B+树索引在数据库中的一个特点就是高扇出性，例如在InnoDB存储引擎中，每个页的大小为16KB</p>
<p>在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错</p>
</blockquote>
<h4 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h4><ul>
<li><p>它们都是平衡多路查找树，是在二叉查找树基础上的改进数据结构</p>
<blockquote>
<p>在二叉查找树上查找一个数据时，最坏情况的查找次数为树的深度，当数据量很大时，查询次数可能还是很大，造成大量的磁盘IO，从而影响查询效率</p>
<p>为了减少磁盘IO的次数，必须降低树的深度，因此在二叉查找树基础上将树改成了多叉加上一些限制条件，就形成了B树</p>
<p>B+树是B树的变种，区别主要是：</p>
<p>对于k阶的B树，每个中间节点只存k-1个值k个指针，而B+树存k个值和k个指针；B树中所有节点中值的总集是全部关键字集合，而B+树中所有叶子节点值的总集就是全部关键字集合；B+树为所有叶子节点增加了链接，从而实现了快速的范围查找</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>B+Tree为什么将数据存储到叶子结点进行冗余<br><strong>data和节点都需要空间存储</strong>，如果将<strong>data移除</strong>，可以<strong>存出更多节点</strong>，MySQL中使用的<strong>B+Tree每一节点可以存储最多16KB数据</strong>可以通过SHOW GLOBAL STATUS LIKE ‘InnoDb_page_size’;这条SQL查询，在16KB的情况下MySQL使用B+Tree可以存储更多的索引元素，若表中id使用bigint当做索引占8Byte，同时使用6Byte记录该节点子节点位置那么一个索引字段占8+6&#x3D;14Byte，16KB&#x2F;14Byte&#x3D;1170，每一个节点可以存储1170个元素</p>
</blockquote>
<blockquote>
<p>B+Tree叶子节点链接<br><strong>B+树中的非叶子节点会冗余一份在叶子节点中</strong>，并且叶子节点之间用指针相连，最开始的Hash不支持范围查询，二叉树树高很高，只有B树跟B+有的一比，B树一个节点可以存储多个元素，相对于红黑树整体的树高降低了，磁盘IO效率提高了</p>
<p>而B+树是B树的升级版，<strong>只是把非叶子节点冗余一下</strong>，这么做的好处是为了<strong>提高范围查找的效率</strong>，提高了的原因也无非是会有指针指向下一个节点的叶子节点</p>
</blockquote>
<ul>
<li><p>B+Tree特点</p>
<blockquote>
<p>所有<strong>关键字都出现在叶子节点的链表</strong>中（稠密索引），且链表中的关键字恰好有序</p>
<p>在B-树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现，<strong>非叶子节点作为叶子节点的索引</strong></p>
<p>B+树总是到叶子节点才命中数据不可能在非叶子节点命中</p>
<p>更适合文件索引系统</p>
<p><strong>单一节点存储的元素更多，使得查询的IO次数更少</strong>，所以也就使得它更适合做为数据库MySQL的底层数据结构</p>
</blockquote>
</li>
</ul>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><ul>
<li><p>聚簇索引是将<strong>数据与索引存储到一起</strong>，找到索引也就找到了数据</p>
</li>
<li><p>非聚簇索引是将<strong>数据和索引存储分离</strong>，索引树的<strong>叶子节点存储了数据行的地址</strong></p>
<blockquote>
<p>在MyISAM中，所有索引都是非聚簇索引，叶子节点存储着数据的地址，对于主键索引和普通索引在存储上没有区别</p>
</blockquote>
<blockquote>
<p>在InnoDB中，<strong>一个表有且仅有一个聚簇索引</strong>（因为<strong>原始数据只留一份</strong>，而数据和聚簇索引在一起），并且该索引是建立在主键上的，即使没有指定主键，也会特殊处理生成一个聚簇索引</p>
<p><strong>其他索引都是辅助索引</strong>，使用<strong>辅助索引访问索引外的其他字段时都需要进行二次查找</strong></p>
<p>在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）</p>
<p>无论是何种索引，<strong>每个页的大小都为16KB</strong>，且不能更改</p>
<p>聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录</p>
<p><strong>辅助索引是根据索引键创建的一棵B+树</strong>，与聚簇索引不同的是，其<strong>叶子节点仅存放索引键值</strong>，以及<strong>该索引键值指向的主键</strong></p>
<p>也就是说，如果通过辅助索引来查找数据，那么当<strong>找到辅助索引的叶子节点后</strong>，很有可能<strong>还需要根据主键值查找聚簇索引来得到数据</strong>，这种查找方式又被称为<strong>书签查找</strong></p>
<p>因为<strong>辅助索引不包含行记录的所有数据</strong>，这就意味着<strong>每页可以存放更多的键值</strong>，因此其<strong>高度一般都要小于聚簇索引</strong></p>
</blockquote>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>事务可以分为以下几种类型：</p>
<blockquote>
<blockquote>
<p><strong>扁平事务</strong>：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务，在扁平事务中，所有操作都处于同一层次，其由<strong>BEGIN WORK开始</strong>，由<strong>COMMIT WORK或ROLLBACK WORK结束</strong>，处于之间的操作是原子的，<strong>要么都执行，要么都回滚</strong></p>
</blockquote>
<blockquote>
<p><strong>带有保存点的扁平事务</strong>：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大</p>
<p><strong>保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态</strong></p>
</blockquote>
<blockquote>
<p><strong>链事务</strong>：可视为保存点模式的一个变种</p>
<p>链事务的思想是：在提交一个事务时，<strong>释放不需要的数据对象</strong>，将<strong>必要的处理上下文隐式地传给下一个要开始的事务</strong></p>
<p><strong>提交事务操作和开始下一个事务操作将合并为一个原子操作</strong>，这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的</p>
</blockquote>
<p><strong>嵌套事务</strong>：是一个层次结构框架，有<strong>一个顶层事务控制着各个层次的事务</strong>，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换</p>
<p><strong>分布式事务</strong>：通常是一个在<strong>分布式环境下运行的扁平事务</strong>，因此需要根据数据所在位置访问网络中的不同节点，对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效</p>
<p>对于MySQL的<strong>InnoDB存储引擎</strong>来说，它<strong>支持扁平事务、带有保存点的扁平事务、链事务、分布式事务</strong>，<strong>不支持嵌套事务</strong>，MySQL数据库并不是原生的，因此对于有并行事务需求的用户来说MySQL就无能为力了，但是用户可以<strong>通过带有保存点的事务来模拟串行的嵌套事务</strong></p>
</blockquote>
</li>
</ul>
<h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h4><ul>
<li><p>ACID代表原子性、一致性、隔离性、持久性</p>
<blockquote>
<p>事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成</p>
<p>在事务中的操作，<strong>要么都执行修改，要么都不执行</strong>，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一</p>
<p>事务需遵循ACID四个特性：</p>
<p>A（atomicity）原子性，原子性指<strong>整个数据库事务是不可分割的工作单位</strong></p>
<p>只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功</p>
<p>事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态</p>
<p>C（consistency）一致性，一致性指事务将数据库从一种状态转变为另一种一致的状态</p>
<p><strong>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</strong></p>
<p>I（isolation）隔离性，事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即<strong>该事务提交前对其他事务都不可见</strong>，这通常使用锁来实现</p>
<p>D（durability）持久性，<strong>事务一旦提交，其结果就是永久性的</strong>，即使发生宕机等故障，数据库也能将数据恢复，持久性保证的是事务系统的高可靠性，而不是高可用性</p>
</blockquote>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><p>读未提交、读已提交、可重复读、可串行化</p>
<blockquote>
<p>读未提交可能出现脏读、幻读、不可重复读</p>
<p>读已提交可以避免脏读</p>
<p>可重复读可以避免脏读和不可重复读</p>
<p>可串行化可以避免脏读、幻读、不可重复读</p>
</blockquote>
</li>
<li><p><strong>InnoDB存储引擎</strong>默认的支持隔离级别是<strong>REPEATABLE READ</strong>，但是<strong>与标准SQL不同</strong>的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，<strong>使用Next-Key Lock的锁算法</strong>，因此<strong>避免了幻读的产生</strong>，InnoDB存储引擎在<strong>默认的事务隔离级别下已经能完全保证事务的隔离性要求</strong>，即达到SQL标准的SERIALIZABLE隔离级别</p>
</li>
</ul>
<blockquote>
<p>READ UNCOMMITTED： 它是性能最好、也最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离</p>
<p>SERIALIZABLE：</p>
<p><strong>读的时候加共享锁</strong>，其他事务可以并发读，但是<strong>不能写</strong></p>
<p><strong>写的时候加排它锁</strong>，其他事务<strong>不能并发写也不能并发读</strong></p>
<p>REPEATABLE READ &amp; READ COMMITTED： 为了<strong>解决不可重复读</strong>，<strong>MySQL 采用了 MVVC (多版本并发控制)</strong> 的方式</p>
<p>我们在数据库表中看到的一行记录可能实际上<strong>有多个版本</strong>，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 <strong>row trx_id</strong>，而这个字段就是<strong>使其产生的事务的 id</strong>，<strong>事务 ID</strong> 记为 transaction id，它在<strong>事务开始的时候向事务系统申请</strong>，按<strong>时间先后顺序递增</strong></p>
</blockquote>
<ul>
<li><p>Next-Key Lock</p>
<blockquote>
<p>是行锁和间隙锁的结合，在给被查询的索引列加锁的同时还会给被查询数据附近的一定范围内的数据加锁，目的是防止该范围内记录被修改</p>
</blockquote>
</li>
</ul>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul>
<li><p>乐观锁：</p>
<blockquote>
<p>乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现</p>
<p>乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁</p>
</blockquote>
</li>
<li><p>悲观锁：</p>
<blockquote>
<p>悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁</p>
</blockquote>
</li>
<li><p>使用场景：</p>
<blockquote>
<p>乐观锁：</p>
<blockquote>
<p>GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景</p>
<p>例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器</p>
<p>这其实就是乐观锁的实现全过程</p>
</blockquote>
<p>悲观锁：</p>
<blockquote>
<p>悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重</p>
<p>因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><ul>
<li><p>复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用</p>
<blockquote>
<p>总体来说，replication的工作原理分为以下3个步骤：</p>
<p><strong>主服务器把数据更改记录到二进制日志中</strong></p>
<p>从服务器<strong>把主服务器的二进制日志复制到自己的中继日志中</strong></p>
<p>从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性</p>
<p>复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原</p>
<p>不同的是这个二进制日志的还原操作基本上实时在进行中，这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时</p>
<p>这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大</p>
</blockquote>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>创建型包括：单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式</li>
<li>结构型包括：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式和享元模式</li>
<li>行为型包括：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介者模式、观察者模式、备忘录模式、访问者模式、状态模式和解释器模式</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li><p>单例模式（Singleton Pattern）是最简单的创建型设计模式，它会确保一个类只有一个实例存在</p>
<blockquote>
<p>单例模式最重要的特点就是构造函数私有，从而避免外界直接使用构造函数直接实例化该类的对象</p>
<p>单例模式在Java中两种表现形式：</p>
<p>饿汉式：类加载时就进行对象实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getPerson</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> person;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：第一次引用类时才进行对象实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Person person;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">         person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> person;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通懒汉式在多个线程同时访问时可能破坏单例模式</p>
<p>因此通常需要加上同步机制（双重检查）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Person person;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Person.class) &#123;</span><br><span class="line">             <span class="keyword">if</span>(person == <span class="literal">null</span>)&#123;</span><br><span class="line">             person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> person;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式的优点：</p>
<p>在一个对象需要频繁的销毁、创建，而销毁、创建性能又无法优化时，单例模式的优势尤其明显</p>
<p>在一个<strong>对象的产生需要比较多资源时</strong>，如读取配置、产生其他依赖对象时，则可以通过在启用时直接产生一个单例对象，然后用<strong>永久驻留内存</strong>的方式来解决</p>
<p>单例模式可以<strong>避免对资源的多重占用</strong>，因为只有一个实例，避免了<strong>对一个共享资源的并发操作</strong></p>
<p>单例模式可以在<strong>系统设置全局的访问点，优化和共享资源访问</strong></p>
<p>单例模式的缺点：</p>
<p>单例模式<strong>无法创建子类，扩展困难</strong>，若要扩展，除了修改代码基本上没有第二种途径可以实现</p>
<p>单例模式<strong>对测试不利</strong>，在并行开发环境中，如果采用单例模式的类没有完成，是不能进行测试的</p>
<p>单例模式与<strong>单一职责原则有冲突</strong>，一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要用单例模式取决于环境</p>
</blockquote>
</li>
</ul>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul>
<li>工厂模式（Factory Method Pattern）也叫虚拟构造函数模式或多态性工厂模式，其用意是定义一个创建产品对象的工厂接口，将实际创建性工作推迟到子类中</li>
<li>工厂模式可以分为简单工厂、工厂方法和抽象工厂模式</li>
</ul>
<blockquote>
<p>简单工厂模式严格来讲并不算是一种设计模式，更多的时候是一种编程习惯</p>
<p>简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口，简单工厂适用于需要创建的对象较少或客户端不关心对象的创建过程的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITea</span> &#123;</span><br><span class="line"><span class="comment">// 沏茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义俩种茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongjingTea</span> <span class="keyword">implements</span> <span class="title class_">ITea</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;西湖龙井&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiluochunTea</span> <span class="keyword">implements</span> <span class="title class_">ITea</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;碧螺春&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  准备沏一杯茶，根据传入的参数决定不同的茶叶类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeaFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ITea <span class="title function_">createTea</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">ITea</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;longjing&quot;</span>))&#123;</span><br><span class="line">            tea = <span class="keyword">new</span> <span class="title class_">LongjingTea</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;biluochun&quot;</span>))&#123;</span><br><span class="line">            tea = <span class="keyword">new</span> <span class="title class_">BiluochunTea</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tea != <span class="literal">null</span>)&#123;</span><br><span class="line">            tea.makeTea();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TeaFactory</span> <span class="variable">teaFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeaFactory</span>();</span><br><span class="line">    <span class="type">ITea</span> <span class="variable">tea</span> <span class="operator">=</span> teaFactory.createTea(<span class="string">&quot;longjing&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>工厂方法模式</p>
<p>工厂方法模式具有良好的封装性，代码结构清晰，一个对象创建是有条件约束的，如果一个调用者需要一个具体的产品对象，只要知道这个产品的类名或约束字符串即可，不用知道创建对象的过程如何，降低了模块间的耦合</p>
<p>工厂模式还拥有优秀的可扩展性，在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以适应变化</p>
<p>工厂方法模式是典型的解耦框架，高层模块只需要知道产品的抽象类或接口，其他的实现类都不用关心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITea</span> &#123;</span><br><span class="line"><span class="comment">// 沏茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义俩种茶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongjingTea</span> <span class="keyword">implements</span> <span class="title class_">ITea</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;西湖龙井&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiluochunTea</span> <span class="keyword">implements</span> <span class="title class_">ITea</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeTea</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;碧螺春&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongjingTeaFactory</span> <span class="keyword">implements</span> <span class="title class_">ITeaFactory</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> ITea <span class="title function_">createTea</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LongjingTea</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiluochunTeaFactory</span> <span class="keyword">implements</span> <span class="title class_">ITeaFactory</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> ITea <span class="title function_">createTea</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BiluochunTea</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">ITeaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongjingTeaFactory</span>();</span><br><span class="line">     factory.createTea();</span><br><span class="line"></span><br><span class="line">     factory = <span class="keyword">new</span> <span class="title class_">BiluochunTeaFactory</span>();</span><br><span class="line">     factory.createTea();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式</p>
<p>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类</p>
<p>抽象工厂模式是工厂方法模式的升级版本</p>
<p>在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式，抽象方法适用于下和工厂方法一样客户端不需要知道它所创建的对象的类，需要一组对象共同完成某种功能，可能存在多组对象完成不同功能以及系统结构稳定，不会频繁的增加对象的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冰箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFridge</span> &#123;</span><br><span class="line"> <span class="comment">// 冷藏</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">coldStorage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//洗衣机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IWasher</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">wash</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeideFridge</span> <span class="keyword">implements</span> <span class="title class_">IFridge</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coldStorage</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;美的冰箱&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeideWasher</span> <span class="keyword">implements</span> <span class="title class_">IWasher</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wash</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;美的洗衣机&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeliFridge</span> <span class="keyword">implements</span> <span class="title class_">IFridge</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coldStorage</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;格力冰箱&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeliWasher</span> <span class="keyword">implements</span> <span class="title class_">IWasher</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wash</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;格力洗衣机&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂接口，家用电器工厂，生产冰箱和洗衣机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouseholdElectricFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    IFridge <span class="title function_">createFridge</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    IWasher <span class="title function_">createWasher</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeideHouseholdFactory</span> <span class="keyword">implements</span> <span class="title class_">IHouseholdElectricFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IFridge <span class="title function_">createFridge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MeideFridge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IWasher <span class="title function_">createWasher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MeideWasher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeliHouseholdFactory</span> <span class="keyword">implements</span> <span class="title class_">IHouseholdElectricFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IFridge <span class="title function_">createFridge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GeliFridge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IWasher <span class="title function_">createWasher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GeliWasher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">IHouseholdElectricFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MeideHouseholdFactory</span>();</span><br><span class="line">        factory.createFridge().coldStorage();</span><br><span class="line">        factory.createWasher().wash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>总结</p>
<blockquote>
<p>共性：</p>
<blockquote>
<p>产品类或产品接口</p>
<p>工厂接口或者工厂类</p>
<p>客户端</p>
<p>产品类的多种实现</p>
</blockquote>
<p>简单工厂：</p>
<blockquote>
<p>工厂类为实现类，内部有产品创建方法</p>
<p>客户端创建工厂类，调用工厂类的方法</p>
<p>根据调用方法的参数不同返回不同的产品</p>
</blockquote>
<p>工厂方法：</p>
<blockquote>
<p>工厂接口，接口种有产品创建方法</p>
<p>自主实现工厂接口，工厂子类自主实现接口方法</p>
<p>客户端创建不同工厂子类，调用生产产品方法得到目标产品</p>
<p>一个工厂只负责一种产品的生产</p>
<p>创建不同的子类工厂就产生不同的产品</p>
</blockquote>
<p>抽象工厂：</p>
<blockquote>
<p>工厂接口种有多种产品的创建方法</p>
<p>自主实现工厂接口，工厂子类自主实现接口方法</p>
<p>客户端创建不同工厂子类，一个子类实例调用不同的生产方法生成不同种类的子产品</p>
<p>一个工厂子类负责多种产品的生产</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>简单工厂模式其实并不算是一种设计模式，更多的时候是一种编程习惯</p>
<p>简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口</p>
</blockquote>
<blockquote>
<p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂</p>
<p>也就是说每个对象都有一个与之对应的工厂</p>
<p>工厂方法的实现思路是，定义一个用于创建对象的接口，让子类决定将哪一个类实例化</p>
<p>工厂方法模式让一个类的实例化延迟到其子类</p>
</blockquote>
<blockquote>
<p>抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象</p>
<p>这是和工厂方法最大的不同点</p>
<p>抽象工厂的实现思路是，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</p>
</blockquote>
</blockquote>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h3><ul>
<li><strong>线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源</strong>，而<strong>创建协程</strong>不需要调用操作系统的功能，<strong>编程语言自身就能完成</strong>，所以<strong>协程也被称为用户态线程</strong>，协程比线程轻量很多</li>
<li>线程<strong>在多核环境下是能做到真正意义上的并行</strong>，而<strong>协程是为并发而产生</strong>的</li>
<li>一个具有多个线程的程序可以同时运行几个线程，而<strong>协同程序却需要彼此协作的运行</strong></li>
<li><strong>线程进程都是同步机制</strong>，而<strong>协程则是异步</strong></li>
<li><strong>线程是抢占式</strong>，而协程是非抢占式的，协程需要用户<strong>自己释放使用权来切换到其他协程</strong>，因此<strong>同一时间只有一个协程拥有运行权</strong>，相当于单线程的能力</li>
<li><strong>操作系统对于线程开辟数量限制在千的级别</strong>，而<strong>协程可以达到上万的级别</strong></li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li><p>Linux 操作系统是采用<strong>段页式内存管理方式</strong></p>
<blockquote>
<p><strong>页式存储管理能有效地提高内存利用率</strong>（解决内存碎片），而<strong>分段存储管理能反映程序的逻辑结构并有利于段的共享</strong></p>
<p>将这两种存储管理方法结合起来，就形成了段页式存储管理方式</p>
<p>段页式存储管理方式即<strong>先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名</strong></p>
<p>在段页式系统中，为了<strong>实现从逻辑地址到物理地址的转换</strong>，系统中需要<strong>同时配置段表和页表</strong>，<strong>利用段表和页表进行从用户地址空间到物理内存空间的映射</strong></p>
<p><strong>系统为每一个进程建立一张段表</strong>，<strong>每个分段有一张页表</strong></p>
<p><strong>段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号</strong></p>
<p>在进行<strong>地址转换</strong>时，首先<strong>通过段表查到页表始址</strong>，然后<strong>通过页表找到页帧号</strong>，最终<strong>形成物理地址</strong></p>
</blockquote>
</li>
</ul>
<h3 id="虚拟内存和物理内存的区别"><a href="#虚拟内存和物理内存的区别" class="headerlink" title="虚拟内存和物理内存的区别"></a>虚拟内存和物理内存的区别</h3><ul>
<li><p>物理内存</p>
<blockquote>
<p>以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址</p>
<p>程序能寻址的范围是有限的，这取决于 CPU 的地址线条数，比如在 32 位平台下，寻址的范围是 2^32 也就是 4G</p>
<p>并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给 4G 物理内存，就可能会出现很多问题：</p>
<p>因为<strong>物理内存是有限</strong>的，当有多个进程要执行的时候，都要给 4G 内存，很显然内存不够，这很快就分配完了，于是<strong>没有得到分配资源的进程就只能等待</strong></p>
<p>当<strong>一个进程执行完了</strong>以后，再<strong>将等待的进程装入内存</strong>，这种频繁的装入内存的操作效率很低</p>
<p>由于<strong>指令都是直接访问物理内存</strong>的，那么<strong>任何进程都可以修改其他进程的数据</strong>，甚至会<strong>修改内核地址空间的数据</strong>，这是<strong>不安全</strong>的</p>
</blockquote>
</li>
<li><p>虚拟内存</p>
<blockquote>
<p>由于物理内存有很多问题，所以出现了虚拟内存</p>
<p>虚拟内存是<strong>计算机系统内存管理的一种技术</strong></p>
<p>它<strong>使得应用程序认为它拥有连续的可用的内存</strong>（一个连续完整的地址空间）</p>
<p>实际上，通常<strong>被分隔成多个物理内存碎片</strong>，还有部分<strong>暂时存储在外部磁盘存储器</strong>上，在<strong>需要时进行数据交换</strong></p>
</blockquote>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程间通讯方式"><a href="#进程间通讯方式" class="headerlink" title="进程间通讯方式"></a>进程间通讯方式</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面是一条Linux命令，命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）的输出，作为后一个命令（grep mysql）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行</p>
<p>同时，我们得知上面这种管道是没有名字，所以<strong>「|」表示的管道称为匿名管道</strong>，用完了就销毁</p>
</blockquote>
<blockquote>
<p>管道还有另外一个类型是<strong>命名管道</strong>，也被叫做 FIFO，因为数据是<strong>先进先出的传输方式</strong></p>
<p>在使用命名管道前，先需要通过 <strong>mkfifo</strong> 命令来创建，并且指定管道名字：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">创建管道</span><br><span class="line">$ mkfifo myPipe</span><br><span class="line"></span><br><span class="line">Linux一切皆文件，所以管道也是以文件的形式存在</span><br><span class="line">查看文件类型，结果如下</span><br><span class="line">$ ls -l</span><br><span class="line">prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe</span><br><span class="line">其中p就是代表pipe管道的意思</span><br><span class="line"></span><br><span class="line">将数据写进管道</span><br><span class="line">$ echo &quot;hello&quot; &gt; myPipe  // 将数据写进管道</span><br><span class="line">                         // 停住了 ...</span><br><span class="line">只有当管道里的数据被读完后，命令才可以正常退出</span><br><span class="line"></span><br><span class="line">执行另外命令来读取这个管道里的数据</span><br><span class="line">$ cat &lt; myPipe  // 读取管道里的数据</span><br><span class="line">hello</span><br><span class="line">另一边也成功退出</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong></p>
</li>
<li><p>管道的创建及原理</p>
<blockquote>
<p>匿名管道的创建，需要通过下面这个系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2])</span><br><span class="line">这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]</span><br><span class="line">注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中</span><br></pre></td></tr></table></figure>

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hY2Y0NTk4Yy0zOWY1LTRlOTEtYTJlMS1jM2Q1NTVkZjBjNjUucG5n?x-oss-process=image/format，png" alt="img" style="zoom: 50%;" />

<p><strong>所谓的管道，就是内核里面的一串缓存</strong></p>
<p>从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据</p>
<p>管道传输的数据是无格式的流且大小受限</p>
<p>如何进行进程间通信</p>
<p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以<strong>通过各自的 fd 写入和读取同一个管道文件</strong>实现跨进程通信了</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83NjkyYWY3Ny0zODBmLTRlZGEtYTIzMi1lZGNhYTI1NGM1YzEucG5n?x-oss-process=image/format，png" alt="img" style="zoom:50%;" />

<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出</p>
<p>那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li>
<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
</ul>
<p>如果需要双向通信，则应该创建两个管道</p>
<p>我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的</p>
<p>在 <strong>shell</strong> 里面<strong>执行 <code>A | B</code>命令</strong>的时候，<strong>A 进程和 B 进程</strong>都是 <strong>shell 创建出来的子进程</strong>，A 和 B 之间不存在父子关系，它俩的父进程都是 shell</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNmExYTllNy1kY2JjLTRmMjUtOTQ3ZC1mNjdhMjg1ZjA2YjAucG5n?x-oss-process=image/format，png" alt="img" style="zoom: 33%;" />

<p>在 shell 里通过「<code>|</code>」<strong>匿名管道将多个命令连接在一起</strong>，实际上也就是<strong>创建了多个子进程</strong>，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销</p>
<p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong></p>
<p>因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的</p>
<p><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong></p>
<p>因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作</p>
</blockquote>
</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据，对于这个问题，<strong>消息队列</strong>的通信模式就可以解决</p>
<ul>
<li><p>A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了，同理，B 进程要给 A 进程发送消息也是如此</p>
<blockquote>
<p><strong>消息队列是保存在内核中的消息链表</strong></p>
<p>在发送数据时，会分成一个一个<strong>独立的数据单元</strong>，也就是<strong>消息体（数据块）</strong>，消息体是用户自定义的数据类型，消息的<strong>发送方和接收方要约定好消息体的数据类型</strong>，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据</p>
<p>如果进程从消息队列中读取了消息体，内核就会把这个消息体删除</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁</p>
</blockquote>
</li>
<li><p>缺点：</p>
<blockquote>
<p>一是<strong>通信不及时</strong></p>
<p>二是<strong>附件也有大小限制</strong></p>
<p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限</p>
<p>在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度</p>
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程</p>
</blockquote>
</li>
</ul>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程，那<strong>共享内存</strong>的方式，就很好的解决了这一问题</p>
<ul>
<li><p>现代操作系统，对于内存管理，采用的是<strong>虚拟内存技术</strong>，也就是<strong>每个进程都有自己独立的虚拟内存空间</strong>，不同进程的虚拟内存<strong>映射到不同的物理内存中</strong>，即使进程的<strong>虚拟地址一样</strong>，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响</p>
</li>
<li><p><strong>共享内存的机制，每个进程拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>，就可以省去拷贝的操作，提高了通讯速度</p>
</li>
</ul>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85MWQwMjBiMy1lMmQ3LTRhZmEtOWY5YS00OWI2ZWRiMDU4ZWUucG5n?x-oss-process=image/format，png" alt="img" style="zoom:50%;" />

<h4 id="信号量-用于共享内存内的进程通讯"><a href="#信号量-用于共享内存内的进程通讯" class="headerlink" title="信号量(用于共享内存内的进程通讯)"></a>信号量(用于共享内存内的进程通讯)</h4><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了，例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问，正好，<strong>信号量</strong>就实现了这一保护机制</p>
<blockquote>
<p>信号量表示资源的数量，控制信号量的方式有两种<strong>原子操作</strong>：</p>
<p>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行</p>
<p>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程</p>
<p>P 操作是用在<strong>进入共享资源之前</strong>，V 操作是用在<strong>离开共享资源之后</strong>，这两个操作是必须成对出现的</p>
</blockquote>
<ul>
<li><p>具体过程：</p>
<blockquote>
<p>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存</p>
<p>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞</p>
<p>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>可以发现，信号初始化为 1，就代表着是<strong>互斥信号量</strong>，它可以<strong>保证共享内存在任何时刻只有一个进程在访问</strong>，这就很好的保护了共享内存</p>
<p>在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务</p>
<p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的</p>
<p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YmI2YmUwMS0wY2JhLTRhMzUtYTkzMS1iZmE5ODFlNGViZDkucG5n?x-oss-process=image/format，png" alt="img" style="zoom:50%;" /></p>
<p>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待</p>
<p>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B</p>
<p>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了</p>
<p>信号初始化为 0，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行</p>
</blockquote>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p><strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程</strong></p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义</p>
<blockquote>
<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+C 产生 SIGINT 信号，表示终止该进程；</span><br><span class="line">Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束；</span><br></pre></td></tr></table></figure>

<p>当进程在后台运行，可以通过 kill 命令的方式给进程发送信号，前提需要知道运行中的进程 PID 号，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程</span><br></pre></td></tr></table></figure>

<p>信号事件的来源主要有<strong>硬件来源</strong>（如键盘 Cltr+C ）和<strong>软件来源</strong>（如 kill 命令）</p>
</blockquote>
<ul>
<li><p>信号是<strong>进程间通信</strong>机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式</p>
<blockquote>
<p><strong>执行默认操作</strong></p>
<p>Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思</p>
<p>Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里</p>
<p><strong>捕捉信号</strong></p>
<p>我们可以为信号定义一个信号处理函数</p>
<p>当信号发生时，我们就执行相应的信号处理函数</p>
<p><strong>忽略信号</strong></p>
<p>当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理</p>
<p>有两个信号是应用进程<strong>无法捕捉和忽略</strong>的，即 <strong>SIGKILL</strong> 和 <strong>SEGSTOP</strong>，它们用于在任何时候<strong>中断或结束某一进程</strong></p>
</blockquote>
</li>
</ul>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了</strong></p>
<p>Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信</p>
<blockquote>
<p>我们来看看创建 socket 的系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain， int type， int protocal)</span><br><span class="line"></span><br><span class="line">domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</span><br><span class="line"></span><br><span class="line">type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字</span><br><span class="line"></span><br><span class="line">protocal 参数原本是用来指定通信协议的，但现在基本废弃因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可</span><br></pre></td></tr></table></figure>

<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<p>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；<br>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；<br>实现本地进程间通信：</p>
<p>「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket</p>
</blockquote>
<p>三种通信的编程模型</p>
<ul>
<li>针对 TCP 协议通信的 socket 编程模型</li>
</ul>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iMDU3MmRkOS03YTI1LTQ0OTUtOWIyZS0wZTg1NjM0MTg1ZTMucG5n?x-oss-process=image/format，png" alt="img" style="zoom: 67%;" />

<blockquote>
<p><strong>服务端和客户端初始化</strong> socket，得到文件描述符</p>
<p>服务端调用 bind，将<strong>绑定在 IP 地址和端口</strong></p>
<p>服务端调用 listen，<strong>进行监听</strong></p>
<p>服务端调用 accept，<strong>等待客户端连接</strong></p>
<p>客户端调用 connect，向服务器端的地址和端口<strong>发起连接请求</strong></p>
<p><strong>服务端 accept 返回用于传输的 socket 的文件描述符</strong></p>
<p>客户端调用 write 写入数据</p>
<p>服务端调用 read 读取数据</p>
<p>客户端断开连接时，会<strong>调用 close</strong>，那么服务端 read 读取数据的时候，就会<strong>读取到了 EOF</strong>，待处理完数据后，<strong>服务端调用 close</strong>，表示连接关闭</p>
<p>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样</p>
</blockquote>
<ul>
<li>针对 UDP 协议通信的 socket 编程模型</li>
</ul>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82NTRjY2Y3NC02MWJkLTQ3OTItYWNlZi1jYWI3ZWUwZGM5YzkucG5n?x-oss-process=image/format，png" alt="img" style="zoom:80%;" />

<blockquote>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind</p>
<p>每次通信时，<strong>调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口</strong></p>
</blockquote>
<ul>
<li>针对本地进程间通信的 socket 编程模型</li>
</ul>
<blockquote>
<p>本地 socket 被用于在同一台主机上进程间通信的场景：</p>
<p>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</p>
<p>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</p>
<p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p>
<p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p>
<p><strong>本地字节流 socket 和 本地数据报 socket</strong> 在 bind 的时候，<strong>不像 TCP 和 UDP 要绑定 IP 地址和端口</strong>，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>每个进程的用户空间都是独立的，不能相互访问，这时就需要<strong>借助内核空间来实现进程间通信</strong>，因为每个进程都是共享一个内核空间</p>
<blockquote>
<p>Linux 内核提供了不少进程间通信的方式，其中<strong>最简单的方式就是管道</strong>，管道分为<strong>「匿名管道」和「命名管道」</strong></p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，<strong>匿名管道是特殊文件只存在于内存</strong>，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是<strong>只能用于存在父子关系的进程间通信</strong>，匿名管道的<strong>生命周期随着进程创建而建立，随着进程终止而消失</strong></p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要<strong>在文件系统创建一个类型为 p 的设备文件</strong>，那么毫无关系的进程就可以通过这个设备文件进行通 信</p>
<p>另外，不管是匿名管道还是命名管道，进程<strong>写入的数据都是缓存在内核中</strong>，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。</p>
</blockquote>
<blockquote>
<p><strong>消息队列</strong>克服了<strong>管道通信的数据是无格式的字节流的问题</strong>，消息队列实际上是<strong>保存在内核的「消息链表」</strong>，消息队列的消息体是可以<strong>用户自定义的数据类型</strong>，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的</p>
<p>消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过<strong>用户态与内核态之间的拷贝</strong>过程</p>
</blockquote>
<blockquote>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间<strong>数据拷贝过程带来的开销</strong>，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快的进程间通信方式</strong>之名</p>
<p>但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱</p>
</blockquote>
<blockquote>
<p>那么，就需要<strong>信号量来保护共享资源</strong>，以确保任何时刻只能有一个进程访问共享资源，这种方式就是<strong>互斥访问</strong></p>
<p>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作</p>
</blockquote>
<blockquote>
<p><strong>信号</strong>是进程间通信机制中<strong>唯一的异步通信机制</strong>，信号可以在<strong>应用进程和内核之间直接交互</strong>，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号</p>
<p>执行默认操作、捕捉信号、忽略信号</p>
<p>有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程</p>
</blockquote>
<blockquote>
<p>前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 <strong>Socket 通信</strong>了</p>
<p>Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是<strong>基于 TCP 协议的通信方式</strong>，一个是<strong>基于 UDP 协议的通信方式</strong>，一个是<strong>本地进程间通信方式</strong></p>
</blockquote>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是<strong>关注多线程竞争共享资源的问题</strong>，<strong>信号量也同样可以在线程间实现互斥与同步</strong>：</p>
<blockquote>
<p>互斥的方式，可保证任意时刻只有一个线程访问共享资源<br>同步的方式，可保证线程 A 应在线程 B 之前执行</p>
</blockquote>
<ul>
<li>读写信号量：读写信号量可能会引起进程阻塞，但是它<strong>允许N个读执行单元同时访问共享资源</strong>，而最多<strong>只允许有一个写执行单元访问共享资源</strong>，因此，读写信号量是一种相对放宽条件的、粒度稍大于信号量的互斥机制</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁</li>
</ul>
<blockquote>
<p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<p>此时称系统处于死锁状态或系统产生了死锁</p>
<p>这些永远在互相等待的进程称为死锁进程</p>
</blockquote>
<ul>
<li><p>产生死锁的原因主要是： </p>
<blockquote>
<p>因为系统资源不足</p>
<p>进程运行推进的顺序不合适</p>
<p>资源分配不当等</p>
</blockquote>
</li>
<li><p>产生死锁的必要条件</p>
<blockquote>
<p>死锁的发生必须具备以下四个必要条件：</p>
<p><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用，如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</p>
<p><strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放</p>
<p><strong>不可剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</p>
<p><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源</p>
</blockquote>
</li>
<li><p>避免死锁：</p>
<blockquote>
<p>避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程链，从而避免死锁，该方法支持多个进程的并行执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程<br>死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法<strong>破坏了系统的并行性和并发性</strong></p>
</blockquote>
</li>
<li><p>预防死锁：具体的做法是破坏产生死锁的四个必要条件之一</p>
</li>
</ul>
<blockquote>
<p><strong>摒弃请求保持条件</strong></p>
<p>系统规定进程运行之前，<strong>一次性申请所有需要的资源</strong>，进程在运行期间不会提出资源请求，从而摒弃请求保持条件</p>
<p><strong>摒弃不可剥夺条件</strong></p>
<p>当一个进程<strong>请求新的资源得不到满足时</strong>，必须<strong>释放占有的资源</strong>，进程运行时占有的资源可以被释放，意味着可以被剥夺</p>
<p><strong>摒弃环路等待条件</strong></p>
<p>可用资源线性排序，申请必须按照需要递增申请，线性申请不再形成环路，从而摒弃了环路等待条件</p>
<p><strong>银行家算法</strong></p>
<p>策略原理：客户申请的贷款是有限的，每次申请需要申请最大资金量，银行家在能够满足贷款时，都应该给用户贷款，客户在使用贷款后，能够及时归还贷款</p>
<p>该算法需要检查申请者对各类资源的最大需求量，如果现存的各类资源可以满足当前它对各类资源的最大需求量时，就满足当前的申请，它总是考虑最坏可能的情况</p>
</blockquote>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>Redis是一款基于<strong>键值对的NoSQL数据库</strong></p>
<blockquote>
<p>与其他键值对数据库不同的是，Redis中拥有string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）等多种数据结构，这给Redis带来了满足多种应用场景的能力，Redis将<strong>所有数据放到内存中</strong>的做法让它的<strong>读写性能</strong>十分惊人</p>
<p><strong>Redis的持久化机制</strong>保证了在发生类似断电，机械故障等情况时，<strong>内存中的数据不会丢失</strong></p>
<p>此外Redis还提供了<strong>键过期、发布订阅、事务、流水线、Lua脚本</strong>等多个附加功能</p>
<p>在合适的情况下使用Redis会大大增强系统的性能，减少开发人员工作量</p>
<p>适合Redis使用的场景：</p>
<p><strong>热点数据的缓存</strong>：redis访问速度快、支持的数据类型丰富，很适合用来存储热点数据</p>
<p><strong>限时业务</strong>：redis中可以<strong>使用expire命令设置一个键的生存时间</strong>，到时间后redis会删除它</p>
<p><strong>计数器</strong>：<strong>incrby命令可以实现原子性的递增</strong>，所以可以<strong>运用于高并发的秒杀活动、分布式序列号的生成</strong></p>
<p><strong>排行榜</strong>：关系型数据库在排行榜方面查询速度普遍偏慢，所以可以<strong>借助redis的SortedSet进行热点数据的排序</strong></p>
<p><strong>分布式锁</strong>：这个主要利用redis的setnx命令进行</p>
<p>延时操作：redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub&#x2F;Sub频道，以便以某种方式接收影响Redis数据集的事件</p>
<p><strong>分页查询、模糊查询</strong>：Redis的set集合中提供了一个zrangebylex方法，通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据，rangebylex key min max 这个就可以返回字典区间的数据可以利用这个特性可以进行模糊查询功能</p>
<p><strong>点赞，好友等相互关系的存储</strong>：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，我们可以通过这一点实现类似共同好友等功能</p>
<p><strong>队列</strong>：由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作</p>
</blockquote>
</li>
</ul>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><ul>
<li><p>Redis主要提供了5种数据结构：</p>
<blockquote>
<p>字符串(String)、哈希(Hash)、列表(List)、集合(set)、有序集合(zset)</p>
<blockquote>
<p>string可以存储字符串、数字和二进制数据，除了值可以是String以外，所有的键也可以是string，string最大可以存储大小为2M的数据</p>
</blockquote>
<p>列表（List）定义为<strong>字符串列表</strong></p>
<blockquote>
<p>按插入顺序排序，可以将元素添加到 Redis 列表的头部或尾部</p>
<p>List保证数据线性有序且元素可重复，它支持lpush、blpush、rpop、brpop等操作，可以<strong>当作简单的消息队列使用</strong></p>
<p>列表的最大长度为 2^32 – 1 个元素（超过 40 亿个元素）</p>
</blockquote>
<p>哈希（Hash）是<strong>键值对的集合</strong></p>
<blockquote>
<p>在 Redis 中，哈希是字符串字段和字符串值之间的映射，它们适合表示对象</p>
<p>每个哈希可以存储多达 2^32– 1 个字段-值对</p>
</blockquote>
<p>集合（set）是 Redis中的无序字符串集合</p>
<blockquote>
<p>它支持<strong>多个set求交集、并集、差集</strong>，适合实现共同关注之类的需求</p>
<p>集合中的最大成员数为 2^32-1 个元素（超过 40 亿个元素）</p>
</blockquote>
<p>有序集合类（zset）类似于集合（set），也是一组非重复的字符串集合</p>
<blockquote>
<p>它通过给每个元素设置一个分数来作为排序的依据，该分数用于获取从最小到最高分数的有序排序集</p>
<p>成员是独特的，但可以重复分数</p>
<p>zset里面当items内容大于64的时候<strong>同时使用了dict和skiplist两种设计实现</strong>，这也会为了排序和查找性能做的优化</p>
<p>关于时间复杂度：</p>
<p><strong>添加和删除都需要修改skiplist</strong>，所以复杂度为<strong>O(log(n))</strong></p>
<p><strong>查找元素直接使用hash</strong>，其<strong>复杂度为O(1)</strong> ，其他的range操作复杂度一般为O(log(n))</p>
<p>当然如果是items内容小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</p>
</blockquote>
<p>Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的</p>
<p>5.0版本中，Redis新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列</p>
</blockquote>
</li>
<li><p>编码</p>
<blockquote>
<p>每种类型支持多个编码，每一种编码采取一个特殊的结构来实现</p>
<p>各类数据结构内部的编码及结构：</p>
<p>string：编码分为int、raw、embstr</p>
<blockquote>
<p>int底层实现为long，当数据为整数型并且可以用long类型表示时可以用long存储</p>
<p>embstr底层实现为占一块内存的SDS结构，当数据为长度不超过32字节的字符串时，选择以此结构连续存储元数据和值</p>
<p>raw底层实现为占两块内存的SDS，用于存储长度超过32字节的字符串数据，此时会在两块内存中分别存储元数据和值</p>
</blockquote>
<p>list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）</p>
<blockquote>
<p>ziplist底层实现为压缩列表，当元素数量小于128且所有元素长度都小于64字节时，使用这种结构来存储</p>
<p>linkedlist底层实现为双端链表，当数据不符合ziplist条件时，使用这种结构存储</p>
<p>3.2版本之后list一般采用quicklist的快速列表结构来代替前两种</p>
</blockquote>
<p>hash：编码分为ziplist、hashtable两种</p>
<blockquote>
<p>其中ziplist底层实现为压缩列表，当键值对数量小于128，并且所有的键值长度都小于64字节时使用这种结构进行存储</p>
<p>hashtable底层实现为字典，当不符合压缩列表存储条件时，使用字典进行存储</p>
</blockquote>
<p>set：编码分为intset和hashtable</p>
<blockquote>
<p>intset底层实现为整数集合，当所有元素都是整数值且数量不超过128个时使用该结构存储，否则使用字典结构存储</p>
</blockquote>
<p>zset：编码分为ziplist和skiplist(hashmap + skiplist)</p>
<blockquote>
<p>当元素数量小于128，并且每个元素长度都小于64字节时，使用ziplist压缩列表结构存储，否则使用skiplist的字典+跳表的结构存储</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="zset与set区别"><a href="#zset与set区别" class="headerlink" title="zset与set区别"></a>zset与set区别</h4><ul>
<li><p>有序集合和集合一样也是 string 类型元素的集合，且不允许重复的成员</p>
<blockquote>
<p>zset每个元素都会关联一个 double 类型的分数，通过分数来为集合中的成员进行从小到大的排序，有序集合的成员是唯一的，但分数 ( score ) 却可以重复</p>
<p>set是通过<strong>哈希表</strong>实现的，所以<strong>添加，删除，查找的复杂度都是 O(1)</strong></p>
<p>zset底层的存储结构包括ziplist或skiplist，在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist，其他时候使用skiplist</p>
<p>当ziplist作为zset的底层存储结构时候，<strong>每个集合元素使用两个紧挨在一起的压缩列表节点</strong>来保存<strong>，第一个节点保存元素的成员</strong>，<strong>第二个节点保存元素的分值</strong></p>
<p>当skiplist作为zset的底层存储结构的时候，使用skiplist<strong>按序保存元素及分值</strong>，使用<strong>dict来保存元素和分值的映射关系</strong></p>
</blockquote>
</li>
<li><p>zset中的skiplist由Hashmap和skiplist共同实现，单独使用Hashmap或skiplist也可以实现有序集合</p>
<blockquote>
<p>Redis使用两种数据结构组合的原因</p>
<p>单独使用Hashmap，虽然能<strong>以O(1) 的时间复杂度查找成员的分值</strong>，但是因为Hashmap是以无序的方式来保存集合元素，所以每次进行<strong>范围操作的时候都要进行排序</strong></p>
<p>单独使用skiplist，虽然<strong>能执行范围操作</strong>，但<strong>查找操作的复杂度却由 O(1)变为了O(logN)</strong></p>
<p>因此Redis使用了两种数据结构来共同实现有序集合</p>
</blockquote>
</li>
</ul>
<h3 id="Redis单线程架构"><a href="#Redis单线程架构" class="headerlink" title="Redis单线程架构"></a>Redis单线程架构</h3><ul>
<li><p>Redis的网络IO和键值对读写是由一个线程来完成的，但Redis的其他功能，例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行，Redis是单线程的只是一种习惯的说法，本质上并不是单线程的</p>
</li>
<li><p>单线程可以<strong>简化数据结构和算法的实现</strong>，并且可以<strong>避免线程切换和竞争造成的消耗</strong>，但某个<strong>命令执行时间过长，会造成其他命令的阻塞</strong></p>
</li>
<li><p>Redis采用了<strong>io多路复用机制</strong>，这带给了Redis并发处理大量客户端请求的能力</p>
</li>
<li><p>Redis<strong>单线程实现为什么这么快</strong>呢？</p>
<blockquote>
<p>对服务端程序来说，<strong>线程切换和锁通常是性能杀手</strong>，而单线程<strong>避免了线程切换和竞争所产生的消耗</strong></p>
<p>Redis的<strong>大部分操作是在内存上完成</strong>的，这是它实现高性能的一个重要原因</p>
<p>Redis还采用了<strong>IO多路复用机制</strong>，使其在<strong>网络IO操作中能并发处理大量的客户端请求</strong>，<strong>实现高吞吐率</strong></p>
</blockquote>
</li>
</ul>
<h3 id="Redis的持久化策略"><a href="#Redis的持久化策略" class="headerlink" title="Redis的持久化策略"></a>Redis的持久化策略</h3><ul>
<li>Redis4.0之后，Redis有<strong>RDB持久化</strong>、<strong>AOF持久化</strong>、<strong>RDB-AOF混合持久化</strong>这三种持久化方式</li>
</ul>
<blockquote>
<p>RDB持久化是<strong>将当前进程数据以生成快照的方式保存到硬盘</strong>的过程，也是Redis<strong>默认的持久化机制</strong></p>
<blockquote>
<p>RDB会<strong>创建一个经过压缩的二进制文件</strong>，这个文件以’.rdb‘结尾，<strong>内部存储了各个数据库的键值对等信息</strong></p>
<p>RDB持久化过程有手动触发和自动触发两种方式</p>
<p>手动触发是指<strong>通过SAVE或BGSAVE命令触发</strong>RDB持久化操作，创建“.rdb”文件</p>
<p>自动触发是指通过配置选项，让服务器在<strong>满足指定条件时自动执行BGSAVE命令</strong></p>
<p>RDB持久化的<strong>优点</strong>是其<strong>生成的二进制文件体积小</strong>，使用该<strong>文件恢复数据的速度非常快</strong></p>
<p>缺点则是<strong>BGSAVE每次运行都要执行fork操作创建子进程</strong>，这<strong>属于重量级操作</strong>，不宜频繁执行，因此，RBD<strong>没法做到实时的持久化</strong></p>
</blockquote>
<p>AOF<strong>以独立日志的方式记录了每次写入的命令</strong>，重启时再<strong>重新执行</strong>AOF文件中的命令来恢复数据</p>
<blockquote>
<p>AOF持久化的优点是与RDB持久化可能丢失大量的数据相比，<strong>AOF持久化的安全性要高很多</strong></p>
<p>通过使用everysec选项，用户可以将数据丢失的时间窗口限制在1秒之内</p>
<p>其缺点则是，AOF文件存储的是协议文本，它的<strong>体积要比二进制格式的”.rdb”文件大很多</strong></p>
<p>AOF需要通过执行AOF文件中的命令来恢复数据库，其<strong>恢复速度比RDB慢很多</strong></p>
<p>AOF在进行<strong>重写时也需要创建子进程</strong>，在<strong>数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞</strong></p>
<p>AOF<strong>解决了数据持久化的实时性</strong>，是目前Redis<strong>主流的持久化方式</strong></p>
</blockquote>
<p>RDB-AOF混合持久化模式是Redis4.0开始引入的，这种模式是<strong>基于AOF持久化构建</strong>而来的</p>
<blockquote>
<p>用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化</p>
<p>Redis服务器在<strong>执行AOF重写操作时</strong>，会像执行BGSAVE命令一样，根据数据库当前的状态<strong>生成相应的RDB数据写入AOF文件</strong>中</p>
<p>对于<strong>重写之后执行的Redis命令</strong>，则<strong>以协议文本的方式追加到AOF文件的末尾</strong>，即RDB数据之后</p>
<p>通过使用RDB-AOF混合持久化，用户可以同时获得RDB持久化和AOF持久化的优点，服务器既可<strong>以通过AOF文件包含的RDB数据来实现快速的数据恢复操作</strong>，又可以<strong>通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内</strong> </p>
</blockquote>
</blockquote>
<ul>
<li><p>RDB手动触发分别对应save和bgsave命令：</p>
<blockquote>
<p>save 命令会<strong>一直阻塞当前Redis服务器到RBD过程完成为止</strong>，所以这种方式在操作内存比较大的实例时会造成长时间阻塞，因此线上环境不建议使用，该命令已经被废弃</p>
<p>bgsave命令会<strong>让Redis进程执行fork创建子进程</strong>，由<strong>子进程负责RBD持久化过程</strong>，完成后自动结束，因此只在fork阶段发生阻塞，一般阻塞的时间也不会很长</p>
<p>因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式</p>
<p>Redis内部还存在自动触发RDB的持久化机制，例如：</p>
<p><strong>使用save相关配置</strong>，如“save m n”，表示m秒内数据集存在n次修改时，自动触发bgsave</p>
<p><strong>从节点执行全量复制操作</strong>，<strong>主节点自动执行bgsave生成RDB文件并发送给从节点</strong></p>
<p>执行<strong>debug reload</strong>命令<strong>重新加载Redis</strong>时，也会<strong>自动触发save操作</strong></p>
<p>默认情况下<strong>执行shutdown命令</strong>时，如果<strong>没有开启AOF持久化功能则自动执行bgsave</strong></p>
</blockquote>
</li>
<li><p>AOF默认不开启，需要修改配置项来启用它：</p>
<blockquote>
<p>appendonly yes # 启用AOF</p>
<p>appendfilename “appendonly.aof” # 设置文件名</p>
<p>文本协议格式具有如下的优点：</p>
<blockquote>
<p>文本协议具有很好的兼容性</p>
<p>直接采用文本协议格式，可以避免二次处理的开销</p>
<p>文本协议具有可读性，方便直接修改和处理</p>
</blockquote>
<p><strong>AOF持久化的文件同步机制</strong>：为了提高程序的写入性能，<strong>现代操作系统会把针对硬盘的多次写操作优化为一次写操作</strong></p>
<blockquote>
<p>当程序调用write对文件写入时，系统不会直接把数据写入硬盘，而是<strong>先将数据写入内存的缓冲区</strong>中</p>
<p>当<strong>达到特定的时间周期或缓冲区写满</strong>时，系统才会<strong>执行flush操作</strong>，<strong>将缓冲区中的数据冲洗至硬盘</strong>中</p>
<p>这种优化机制虽然提高了性能，但也<strong>给程序的写入操作带来了不确定性</strong></p>
<blockquote>
<p>对于AOF这样的持久化功能来说，<strong>冲洗机制将直接影响AOF持久化的安全性</strong></p>
<p>为了消除上述机制的不确定性，Redis向用户<strong>提供了appendfsync选项</strong>，来<strong>控制系统冲洗AOF的频率</strong></p>
<p><strong>Linux的glibc提供了fsync函数，可以将指定文件强制从缓冲区刷到硬盘，上述选项正是基于此函数</strong></p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="利用Redis实现一个分布式锁"><a href="#利用Redis实现一个分布式锁" class="headerlink" title="利用Redis实现一个分布式锁"></a>利用Redis实现一个分布式锁</h3><ul>
<li><p>为什么要实现分布式锁？</p>
<blockquote>
<p>在分布式的环境下，会发生多个server并发修改同一个资源的情况，这种情况下，由于多个server是多个不同的JRE环境，而Java自带的锁局限于当前JRE，所以<strong>Java自带的锁机制在这个场景下是无效的</strong>，那么就<strong>需要我们自己来实现一个分布式锁</strong></p>
</blockquote>
</li>
<li><p>实现分布式锁的方式</p>
<blockquote>
<p>采用Redis实现分布式锁，我们可以在Redis中存一份代表锁的数据，数据格式通常使用字符串即可</p>
<p>首先加锁的逻辑可以通过<code>setnx key value</code>来实现，但如果客户端忘记解锁，那么这种情况就很有可能造成死锁，但如果直接给锁增加过期时间即新增<code>expire key seconds</code>又会发生其他问题，即这两个命令并不是原子性的，那么如果第二步失败，依然无法避免死锁问题</p>
<p>考虑到如上问题，我们最终可以通过<code>set...nx...</code>命令，将加锁、过期命令编排到一起，把他们变成原子操作，这样就可以避免死锁</p>
<p>写法为<code>set key value nx ex seconds</code> </p>
<p>解锁就是将代表锁的那份数据删除，但不能用简单的<code>del key</code>，因为会出现一些问题</p>
<p>比如此时有进程A，如果进程A在任务没有执行完毕时，锁被到期释放了</p>
<p>这种情况下进程A在任务完成后依然会尝试释放锁，因为它的代码逻辑规定它在任务结束后释放锁，但是它的锁早已经被释放过了，那这种情况它释放的就可能是其他线程的锁</p>
<p>为解决这种情况，我们可以在加锁时为key赋一个随机值，来充当进程的标识，进程要记住这个标识</p>
<p>当进程解锁的时候进行判断，是自己持有的锁才能释放，否则不能释放</p>
<p>另外判断，释放这两步需要保持原子性，否则如果第二步失败，就会造成死锁</p>
<p>而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的</p>
<p>综上所述，优化后的实现分布式锁命令如下：</p>
<p>加锁 set key random-value nx ex seconds</p>
<p>解锁 if redis.call(“get”，KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(“del”，KEYS[1]) else return 0 end </p>
</blockquote>
</li>
<li><p>注意：</p>
<blockquote>
<p>上述的分布式锁实现方式是建立在单节点之上的，它可能存在一些问题</p>
<p>比如有一种情况，进程A在主节点加锁成功，但主节点宕机了，那么从节点就会晋升为主节点</p>
<p>那如果此时另一个进程B在新的主节点上加锁成功而原主节点重启了，成为了从节点，系统中就会出现两把锁，这违背了锁的唯一性原则</p>
<p>就是在单个主节点的架构上实现分布式锁，是无法保证高可用的</p>
<p>若要保证分布式锁的高可用，则可以采用多个节点的实现方案</p>
<p>这种方案有很多，而Redis的官方给出的建议是采用RedLock算法的实现方案</p>
<p>该算法基于多个Redis节点，它的基本逻辑如下：</p>
<p>这些节点相互独立，不存在主从复制或者集群协调机制</p>
<p>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功</p>
<p>解锁：向所有的实例发送DEL命令，进行解锁</p>
<p>我们可以自己实现该算法，也可以直接使用Redisson框架</p>
</blockquote>
</li>
</ul>
<h3 id="缓存穿透、击穿、雪崩的区别"><a href="#缓存穿透、击穿、雪崩的区别" class="headerlink" title="缓存穿透、击穿、雪崩的区别"></a>缓存穿透、击穿、雪崩的区别</h3><ul>
<li><p>缓存穿透：是指<strong>客户端查询了根本不存在的数据</strong>，使得<strong>这个请求直达存储层</strong>，<strong>导致其负载过大甚至造成宕机</strong></p>
<blockquote>
<p>这种情况可能是<strong>由于业务层误将缓存和库中的数据删除</strong>造成的，当然也不排除有人恶意攻击，专门访问库中不存在的数据导致缓存穿透</p>
<p>我们可以通过<strong>缓存空对象</strong>的方式和<strong>布隆过滤器</strong>两种方式来解决这一问题</p>
<p>缓存空对象是指<strong>当存储层未命中后</strong>，仍然<strong>将空值存入缓存层</strong> ，当客户端再次访问数据时，缓存层直接返回空值</p>
<p>还可以将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若<strong>请求的数据不存在则直接返回空值</strong></p>
</blockquote>
</li>
<li><p>缓存击穿：当一份访问量非常大的<strong>热点数据缓存失效</strong>的瞬间，<strong>大量的请求直达存储层</strong>，导致<strong>服务崩溃</strong></p>
<blockquote>
<p>缓存击穿可以通过<strong>热点数据不设置过期时间</strong>来解决，这样就不会出现上述的问题，这是“物理”上的永不过期</p>
<p>或者<strong>为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存</strong></p>
<p>我们也可以<strong>通过加互斥锁的方式</strong>来解决缓存击穿，即对数据的访问加互斥锁，当<strong>一个线程访问该数据时，其他线程只能等待</strong>，避免了大量请求直达存储层的问题，线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值</p>
</blockquote>
</li>
<li><p>缓存雪崩：是指当某一时刻<strong>缓存层无法继续提供服务</strong>，导致<strong>所有的请求直达存储层</strong>，造成<strong>数据库宕机</strong></p>
<blockquote>
<p>可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理</p>
<p>缓存雪崩的解决方式有三种</p>
<p>第一种是在<strong>设置过期时间时，附加一个随机数，避免大量的key同时过期</strong></p>
<p>第二种是<strong>启用降级和熔断措施</strong>，即发生雪崩时，若应用<strong>访问的不是核心数据</strong>，则直接<strong>返回预定义信息&#x2F;空值&#x2F;错误信息</strong>，或者在发生雪崩时，对于访问缓存接口的请求，<strong>客户端直接返回</strong>而不会把请求发给Redis，</p>
<p>第三种是<strong>构建高可用的Redis服务</strong>，也就是<strong>采用哨兵或集群模式</strong>，<strong>部署多个Redis实例</strong>，这样即使个别节点宕机，依然可以保持服务的整体可用</p>
</blockquote>
</li>
</ul>
<h3 id="Redis如何与数据库保持双写一致性"><a href="#Redis如何与数据库保持双写一致性" class="headerlink" title="Redis如何与数据库保持双写一致性"></a>Redis如何与数据库保持双写一致性</h3><ul>
<li><p>保证缓存和数据库的双写一致性，共有四种同步策略</p>
<ul>
<li><p>先更新缓存再更新数据库</p>
<blockquote>
<p>先更新缓存的优点是每次数据变化时都能及时地更新缓存，这样不容易出现查询未命中的情况，但这种操作的消耗很大，如果数据需要经过复杂的计算再写入缓存的话，频繁的更新缓存会影响到服务器的性能</p>
<p>如果是写入数据比较频繁的场景，可能会导致频繁的更新缓存却没有业务来读取该数据。</p>
</blockquote>
</li>
<li><p>先更新数据库再更新缓存</p>
</li>
<li><p>先删除缓存再更新数据库</p>
<blockquote>
<p>删除缓存的优点是操作简单，无论更新的操作复杂与否，都是直接删除缓存中的数据</p>
<p>这种做法的缺点则是，当删除了缓存之后，下一次查询容易出现未命中的情况，那么这时就需要再次读取数据库</p>
<p>那么对比而言，删除缓存无疑是更好的选择</p>
<p>先删除缓存再操作数据库的话，如果第二步骤失败可能导致缓存和数据库得到相同的旧数据</p>
</blockquote>
</li>
<li><p>先更新数据库再删除缓存</p>
<blockquote>
<p>先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>出现上述问题的时候，我们一般采用重试机制解决，而为了避免重试机制影响主要业务的执行，一般建议重试机制采用异步的方式执行</p>
<p>当我们采用重试机制之后由于存在并发，先删除缓存依然可能存在缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致的情况</p>
<p>先更新数据库、再删除缓存是影响更小的方案</p>
<p>如果第二步出现失败的情况，则可以采用重试机制解决问题</p>
</blockquote>
<h3 id="如何实现Redis高可用"><a href="#如何实现Redis高可用" class="headerlink" title="如何实现Redis高可用"></a>如何实现Redis高可用</h3><ul>
<li><p>主要有哨兵和集群两种方式可以实现Redis高可用</p>
</li>
<li><p>哨兵： 哨兵模式是Redis的高可用的解决方案，它<strong>由一个或多个Sentinel实例组成Sentinel系统</strong>，<strong>可以监视任意多个主服务器以及这些主服务器属下的所有从服务器</strong></p>
</li>
</ul>
<blockquote>
<p>当哨兵节点<strong>发现有节点不可达</strong>时，会对该节点<strong>做下线标识</strong></p>
<p>如果是<strong>主节点下线</strong>，它还会<strong>和其他Sentinel节点进行“协商”</strong>，当大多数Sentinel节点都认为主节点不可达时，它们会<strong>选举出一个Sentinel节点来完成自动故障转移的工作</strong>，同时会<strong>将这个变化实时通知给Redis应用方</strong></p>
<p>哨兵节点包含如下的特征：</p>
<blockquote>
<p>哨兵节点会<strong>定期监控数据节点，其他哨兵节点是否可达</strong></p>
<p>哨兵节点会<strong>将故障转移的结果通知给应用方</strong></p>
<p>哨兵节点可以<strong>将从节点晋升为主节点，并维护后续正确的主从关系</strong></p>
<p>哨兵模式下，<strong>客户端连接的是哨兵节点集合，从中获取主节点信息</strong></p>
<p><strong>节点的故障判断</strong>是<strong>由多个哨兵节点共同完成的</strong>，可有效地防止误判</p>
<p><strong>哨兵节点集合是由多个哨兵节点组成</strong>的，即使个别哨兵节点不可用，整个集合依然是健壮的</p>
<p><strong>哨兵节点也是独立的Redis节点</strong>，是特殊的Redis节点，它们<strong>不存储数据，只支持部分命令</strong></p>
</blockquote>
</blockquote>
<ul>
<li><p>集群： Redis集群<strong>采用虚拟槽分区来实现数据分片</strong>，它<strong>把所有的键根据哈希函数映射到<code>0-16383</code>整数槽内</strong>，计算公式为<code>slot=CRC16(key)&amp;16383</code>，<strong>每一个节点负责维护一部分槽以及槽所映射的键值数据</strong></p>
<blockquote>
<p>虚拟槽分区具有如下特点：</p>
<p><strong>解耦数据和节点之间的关系，简化了节点扩容和收缩的难度</strong></p>
<p><strong>节点自身维护槽的映射关系</strong>，不需要客户端或者代理服务维护槽分区元数据</p>
<p><strong>支持节点、槽、键之间的映射查询</strong>，用于<strong>数据路由</strong>，<strong>在线伸缩</strong>等场景</p>
</blockquote>
</li>
</ul>
<h3 id="Redis的主从同步机制"><a href="#Redis的主从同步机制" class="headerlink" title="Redis的主从同步机制"></a>Redis的主从同步机制</h3><ul>
<li><p>Redis主从同步是指<strong>任意数量的从节点（slave node）都可以从主节点上（master node）同步数据</strong></p>
<blockquote>
<p>除了<strong>多个 slave 可以连接到同一个 master</strong> 之外，<strong>slave 还可以接受其他 slave 的连接</strong>，这就形成一个树形结构，使得<strong>Redis可执行单层树复制</strong></p>
<p>从2.8版本开始，当启动一个 slave node 的时候，它会<strong>发送一个 <code>PSYNC</code> 命令给 master node</strong></p>
<p>如果<strong>slave node 是第一次连接到 master node</strong>，那么<strong>会触发一次全量复制</strong>，master 会<strong>启动一个后台线程生成一份 <code>RDB</code> 快照文件</strong>，同时还会将从客户端 client <strong>新收到的所有写命令缓存在内存</strong>中</p>
<p><code>RDB</code> 文件生成完毕后， master 会<strong>将这个 <code>RDB</code> 发送给 slave</strong>，slave <strong>会先写入本地磁盘</strong>，然后再<strong>从本地磁盘加载到内存</strong>中，接着 <strong>master 会将内存中缓存的写命令发送到 slave</strong>，slave 也会同步这些数据</p>
<p>slave node 如果跟 master node 有<strong>网络故障，断开了连接，会自动重连</strong>，连接之后 master node <strong>仅会复制给 slave 部分缺少的数据</strong></p>
</blockquote>
</li>
</ul>
<h3 id="Redis的缓存淘汰策略"><a href="#Redis的缓存淘汰策略" class="headerlink" title="Redis的缓存淘汰策略"></a>Redis的缓存淘汰策略</h3><ul>
<li><p>Redis有如下两种过期策略：</p>
</li>
<li><p>惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key</p>
</li>
<li><p>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描， 过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略</p>
<blockquote>
<p>该策略的删除逻辑如下：</p>
<ol>
<li>从过期字典中随机选择20个key</li>
<li>删除这20个key中已过期的key</li>
<li>如果已过期key的比例超过25%，则重复步骤1</li>
</ol>
<p>当写入数据将导致超出maxmemory限制时，Redis会采用maxmemory-policy所指定的策略进行数据淘汰</p>
<p>该策略一共包含8种选项，其中除了noeviction直接返回错误之外</p>
<p>筛选键的方式分为volatile和allkeys两种</p>
<p>volatile前缀代表从设置了过期时间的键中淘汰数据</p>
<p>allkeys前缀代表从所有的键中淘汰数据关于后缀</p>
<p>ttl代表选择过期时间最小的键</p>
<p>random代表随机选择键</p>
<p>需要我们额外关注的是LRU和LFU后缀，它们分别代表采用LRU算法和LFU算法来淘汰数据</p>
<p>因为allkeys是筛选所有的键，所以不存在ttl，余下三个后缀二者都有，LFU算法是再Redis4版本才提出来的</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>LRU（Least Recently Used）是<strong>按照最近最少使用原则来筛选数据</strong>，即最不常用的数据会被筛选出来</p>
<blockquote>
<p>标准LRU：把<strong>所有的数据组成一个链表</strong>，<strong>表头和表尾分别表示MRU和LRU端</strong>，即最常使用端和最少使用端</p>
<p><strong>刚被访问的数据会被移动到MRU端</strong>，而新增的数据也是刚被访问的数据，也会被移动到MRU端</p>
<p>当<strong>链表的空间被占满时，它会删除LRU端的数据</strong></p>
<p>近似LRU：Redis会<strong>记录每个数据的最近一次访问的时间戳</strong>（LRU）</p>
<p>Redis执行写入操作时，若发现内存超出maxmemory，就会<strong>执行一次近似LRU淘汰算法</strong></p>
<p>近似LRU<strong>会随机采样N个key，然后淘汰掉最旧的key</strong>，若<strong>淘汰后内存依然超出限制，则继续采样淘汰</strong></p>
<p>可以通过maxmemory_samples配置项，设置近似LRU每次采样的数据个数，该配置项的默认值为5</p>
</blockquote>
<p>LRU算法的不足之处在于，若一个key很少被访问，只是刚刚偶尔被访问了一次，则它就被认为是热点数据，短时间内不会被淘汰</p>
<p>LFU算法正式用于解决上述问题</p>
<p>LFU（Least Frequently Used）是Redis4新增的淘汰策略，它<strong>根据key的最近访问频率进行淘汰</strong></p>
<blockquote>
<p>LFU在LRU的基础上，<strong>为每个数据增加了一个计数器</strong>，来统计这个数据的访问次数</p>
<p>当使用LFU策略淘汰数据时，<strong>首先会根据数据的访问次数进行筛选</strong>，把访问次数最低的数据淘汰出内存</p>
<p>如果两个数据的<strong>访问次数相同</strong>，LFU<strong>再比较这两个数据的访问时间</strong>，把访问时间更早的数据淘汰出内存</p>
</blockquote>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ammwxgm.github.io/MMM">Amm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ammwxgm.github.io/MMM/2022/10/25/java/">https://ammwxgm.github.io/MMM/2022/10/25/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ammwxgm.github.io/MMM" target="_blank">Amm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/MMM/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post_share"><div class="social-share" data-image="https://ammwxgm.github.io/MMM/img/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/MMM/2022/10/25/hello-world/"><img class="next-cover" src="https://ammwxgm.github.io/MMM/img/cover.jpg" onerror="onerror=null;src='/MMM/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://ammwxgm.github.io/MMM/img/header.jpg" onerror="this.onerror=null;this.src='/MMM/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Amm</div><div class="author-info__description">心外无物</div></div><div class="card-info-data site-data is-center"><a href="/MMM/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/MMM/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/MMM/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java"><span class="toc-number">1.</span> <span class="toc-text">java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%AF%B9%E6%AF%94C"><span class="toc-number">1.1.</span> <span class="toc-text">java对比C++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java8"><span class="toc-number">1.2.</span> <span class="toc-text">java8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程的创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3 run()和start()有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.4.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">进程、线程、多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JUC"><span class="toc-number">1.3.7.</span> <span class="toc-text">JUC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">如何保证线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%EF%BC%88%E4%BD%9C%E7%94%A8%E3%80%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.3.9.</span> <span class="toc-text">ThreadLocal（作用、实现机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.10.</span> <span class="toc-text">线程同步的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-number">1.3.11.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronize%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.12.</span> <span class="toc-text">synchronize的用法及原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%92%8CLock%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.13.</span> <span class="toc-text">synchronized和Lock区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS"><span class="toc-number">1.3.14.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS"><span class="toc-number">1.3.15.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-number">1.3.16.</span> <span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wt-%E5%92%8Csleep"><span class="toc-number">1.3.17.</span> <span class="toc-text">wt()和sleep()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.4.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E5%92%8CSet"><span class="toc-number">1.5.2.</span> <span class="toc-text">List和Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.</span> <span class="toc-text">ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.4.</span> <span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.5.5.</span> <span class="toc-text">线程安全的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.5.6.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%EF%BC%88JDK-1-8%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">***ConcurrentHashMap（JDK 1.8）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">1.5.8.</span> <span class="toc-text">***HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.5.9.</span> <span class="toc-text">**泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">基本数据类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-jdk-1-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">自动拆箱和自动装箱(jdk 1.5)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.8.1.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">1.9.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.9.2.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">垃圾回收方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.5.</span> <span class="toc-text">垃圾回收算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.10.</span> <span class="toc-text">*类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.10.1.</span> <span class="toc-text">垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-number">1.10.2.</span> <span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1"><span class="toc-number">1.10.3.</span> <span class="toc-text">G1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.10.4.</span> <span class="toc-text">GC的可达性分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.10.5.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.10.6.</span> <span class="toc-text">类实例化的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.7.</span> <span class="toc-text">Java四种引用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.</span> <span class="toc-text">抽象类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E5%92%8Cequals"><span class="toc-number">1.12.</span> <span class="toc-text">&#x3D;&#x3D;和equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E5%92%8Cequals"><span class="toc-number">1.13.</span> <span class="toc-text">hashCode()和equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.14.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.14.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">1.14.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">1.14.3.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.15.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.15.1.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">重载和重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.16.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#error%E5%92%8Cexception"><span class="toc-number">1.16.1.</span> <span class="toc-text">error和exception</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.16.2.</span> <span class="toc-text">异常处理机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.17.</span> <span class="toc-text">I&#x2F;O多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">BeanFactory和FactoryBean的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">2.3.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">2.4.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.5.</span> <span class="toc-text">@Autowired和@Resource注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">Spring事务管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC"><span class="toc-number">2.7.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.1.</span> <span class="toc-text">SpringMVC执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.8.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis"><span class="toc-number">2.9.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.1.</span> <span class="toc-text">在MyBatis中$和#的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.2.</span> <span class="toc-text">Mybatis缓存机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-number">2.10.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">2.10.1.</span> <span class="toc-text">SpringBoot启动依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.10.2.</span> <span class="toc-text">SpringBoot启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">2.10.3.</span> <span class="toc-text">SpringBoot的自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.10.4.</span> <span class="toc-text">SpringBoot常用注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-number">3.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">数据库底层数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E"><span class="toc-number">3.2.</span> <span class="toc-text">数据库引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#innoDB%E5%92%8Cmyisam%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.1.</span> <span class="toc-text">innoDB和myisam的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84MVCC"><span class="toc-number">3.2.2.</span> <span class="toc-text">InnoDB的MVCC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.</span> <span class="toc-text">MySQL索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">数据库索引的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E4%B8%8EB-%E6%A0%91"><span class="toc-number">3.3.2.</span> <span class="toc-text">B树与B+树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">聚簇索引和非聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ACID%E7%89%B9%E6%80%A7"><span class="toc-number">3.4.2.</span> <span class="toc-text">ACID特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">3.6.</span> <span class="toc-text">主从同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text">工厂模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number"></span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">0.1.</span> <span class="toc-text">线程和协程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">0.2.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">0.3.</span> <span class="toc-text">虚拟内存和物理内存的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">进程间通讯方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-%E7%94%A8%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%86%85%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">信号量(用于共享内存内的进程通讯)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.5.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-number">1.1.6.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zset%E4%B8%8Eset%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">zset与set区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">Redis单线程架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">Redis的持久化策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">利用Redis实现一个分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">缓存穿透、击穿、雪崩的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E6%8C%81%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.6.</span> <span class="toc-text">Redis如何与数据库保持双写一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Redis%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">如何实现Redis高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.8.</span> <span class="toc-text">Redis的主从同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.9.</span> <span class="toc-text">Redis的缓存淘汰策略</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/MMM/2022/10/25/java/" title="java面试题"><img src="https://ammwxgm.github.io/MMM/img/cover.jpg" onerror="this.onerror=null;this.src='/MMM/img/404.jpg'" alt="java面试题"/></a><div class="content"><a class="title" href="/MMM/2022/10/25/java/" title="java面试题">java面试题</a><time datetime="2022-10-25T10:23:56.000Z" title="发表于 2022-10-25 18:23:56">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/MMM/2022/10/25/hello-world/" title="Hello World"><img src="https://ammwxgm.github.io/MMM/img/cover.jpg" onerror="this.onerror=null;this.src='/MMM/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/MMM/2022/10/25/hello-world/" title="Hello World">Hello World</a><time datetime="2022-10-25T00:55:20.337Z" title="发表于 2022-10-25 08:55:20">2022-10-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: #ffffff"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Amm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/MMM/js/utils.js"></script><script src="/MMM/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8216654036" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>